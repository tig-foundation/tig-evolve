{
  "id": "3577ad71-c1a2-482d-88d3-8ce52ab8e670",
  "idea": {
    "description": "Hybrid Sobol-CVT Initialization with Power Diagram Refinement and SLSQP Optimization for Exact Circle Packing.",
    "motivation": "This idea is motivated by the need to generate a valid, non-overlapping packing with maximal summed radii while maintaining simplicity in early-stage development. By combining robust probabilistic initialization with geometric refinement and rigorous local optimization, the algorithm targets both feasibility and optimality under non-overlap and containment constraints.",
    "implementation_notes": "\u2022 Use a scrambled Sobol sequence to generate diverse candidate centers.\n\u2022 Configure a quadtree for efficient spatial querying with node capacity set between 4 and 10 and maximum depth of 5\u20136 levels to adapt to 26\u201332 centers.\n\u2022 Apply a weighted Centroidal Voronoi Tessellation (CVT) update to improve center distribution. This involves recalculating centroids based on area and weight, similar to a Laguerre tessellation approach.\n\u2022 Compute power diagrams by lifting points to 3D and using scipy\u2019s ConvexHull; use Shapely to clip cells to the unit square and compute the maximum inscribed circle with high precision.\n\u2022 Formulate non-overlap constraints as (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 \u2265 0 and boundary constraints to keep circles within [r, 1-r]. Include analytic gradient functions for these constraints as outlined in standard SLSQP tutorials.\n\u2022 Optimize the configuration using SciPy's SLSQP with the computed analytic gradients. If near-feasible configurations exhibit small violations, apply a radial bisection correction to refine radii iteratively until convergence is reached.\n\u2022 Optionally, extra interval arithmetic verification can be incorporated in future iterations to further ensure global feasibility.",
    "pseudocode": "centers = generate_sobol_points(n)\nquadtree = build_quadtree(unit_square, centers, capacity=5, max_depth=6)  // capacity chosen between 4-10\ncenters = weighted_CVT_update(centers, quadtree)\nfor each center in centers:\n    cell = compute_power_cell(center, centers)  // lift to 3D, convex hull, then clip with Shapely\n    (new_center, new_radius) = compute_max_inscribed_circle(cell)  // use high-precision geometric functions\n    update circle center and radius\nconfiguration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nif near_feasible(configuration) and constraint_violations(configuration):\n    configuration = radial_bisection_correction(configuration)  // refine radii based on tolerance thresholds\n    configuration = SLSQP_optimize(configuration, constraints, analytic_gradients)\nreturn configuration",
    "originality": {
      "score": 8,
      "positive": "The idea integrates a diverse Sobol-based initialization with CVT-driven refinement and exact geometric correction via power diagrams, which is a novel synthesis in this context.",
      "negative": "The combination of multiple advanced modules requires careful tuning and integration, which may complicate convergence if not calibrated appropriately."
    },
    "future_potential": {
      "score": 8,
      "positive": "Its modular design allows future components such as global verification (via interval arithmetic) to be added or replaced, making it extensible to other packing and geometric optimization problems.",
      "negative": "The reliance on precise CVT and geometric computations may pose scaling challenges if extended to significantly larger or more complex instances."
    },
    "code_difficulty": {
      "score": 7,
      "positive": "The approach leverages well-established libraries (numpy, scipy, Shapely) with clear modular components, facilitating iterative improvements. The integration of analytic gradients and quadtree configurations is supported by existing tutorials and research.",
      "negative": "Integrating the CVT, power diagram extraction, analytic gradient computation, and SLSQP optimization into a single workflow demands rigorous testing, careful parameter tuning, and debugging for diverse configurations."
    }
  },
  "timestamp": 1750151531.4216883,
  "parent_id": "af834fdc-51f2-4d0c-8820-d597693a92b9",
  "evolution_history": [
    {
      "description": "A hybrid algorithm that integrates exact power diagram calculation with iterative refinement. The method starts by seeding circle centers, then computes an exact weighted Voronoi (power) diagram using the transformation of weighted points and 3D convex hull. It updates each circle's parameters by calculating the maximum inscribed circle within each power cell (using Shapely with precision settings) and refines the configuration using SLSQP with robust non-overlap constraints.",
      "motivation": "This approach leverages an exact geometric partitioning method to produce high-quality initial conditions, while overcoming the inaccuracy of pure numerical optimization. It ensures valid packings by combining exact power diagram computations and rigorous geometric verification, essential for advancing early-stage research on circle packing in a unit square.",
      "implementation_notes": "Implement using numpy for vectorized operations, scipy.spatial.ConvexHull for exact power diagram extraction (via transforming points to 3D), and Shapely for robust geometric checks (set_precision, buffering, and tolerance-based distance comparisons). Develop a loop that updates centers and radii iteratively and refines the configuration with SLSQP under strict non-overlap and containment constraints, referencing benchmark packings for n=26 to 32.",
      "pseudocode": "initialize centers and radii; while not converged:\n    transform centers to weighted points: (x, y, x^2+y^2-r^2);\n    compute 3D convex hull; extract lower faces to form power diagram; \n    for each power cell:\n         extract polygon vertices; \n         compute centroid and maximum inscribed circle (using Shapely with fixed precision);\n    update centers and radii; \n    refine via SLSQP with non-overlap and boundary constraints; \n    validate using Shapely (distance checks and buffers); \nreturn optimal packing",
      "originality": {
        "score": 6,
        "positive": "It creatively integrates exact power diagram computation (using a 3D convex hull method) with iterative numerical refinement, which is a novel combination for this circle packing problem.",
        "negative": "The idea builds partially on established methods; careful implementation is required to manage the complexity and numerical precision."
      },
      "future_potential": {
        "score": 8,
        "positive": "The method is scalable to other packing problems and can be further refined with advanced verification techniques, providing a rich ground for future research.",
        "negative": "Incremental improvements may be needed to ensure global optimality beyond local refinements."
      },
      "code_difficulty": {
        "score": 6,
        "positive": "The algorithm is implementable with available Python libraries and modular steps, allowing iterative improvements and integration of robust geometric operations.",
        "negative": "Implementing an exact power diagram and handling precision with Shapely increases the complexity compared to a basic SLSQP approach."
      }
    },
    {
      "description": "Hybrid Sobol-CVT Initialization with Power Diagram Refinement and SLSQP Optimization for Exact Circle Packing.",
      "motivation": "This idea is motivated by the need to generate a valid, non-overlapping packing with maximal summed radii while maintaining simplicity in early-stage development. By combining robust probabilistic initialization with geometric refinement and rigorous local optimization, the algorithm targets both feasibility and optimality under non-overlap and containment constraints.",
      "implementation_notes": "\u2022 Use a scrambled Sobol sequence to generate diverse candidate centers.\n\u2022 Configure a quadtree for efficient spatial querying with node capacity set between 4 and 10 and maximum depth of 5\u20136 levels to adapt to 26\u201332 centers.\n\u2022 Apply a weighted Centroidal Voronoi Tessellation (CVT) update to improve center distribution. This involves recalculating centroids based on area and weight, similar to a Laguerre tessellation approach.\n\u2022 Compute power diagrams by lifting points to 3D and using scipy\u2019s ConvexHull; use Shapely to clip cells to the unit square and compute the maximum inscribed circle with high precision.\n\u2022 Formulate non-overlap constraints as (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 \u2265 0 and boundary constraints to keep circles within [r, 1-r]. Include analytic gradient functions for these constraints as outlined in standard SLSQP tutorials.\n\u2022 Optimize the configuration using SciPy's SLSQP with the computed analytic gradients. If near-feasible configurations exhibit small violations, apply a radial bisection correction to refine radii iteratively until convergence is reached.\n\u2022 Optionally, extra interval arithmetic verification can be incorporated in future iterations to further ensure global feasibility.",
      "pseudocode": "centers = generate_sobol_points(n)\nquadtree = build_quadtree(unit_square, centers, capacity=5, max_depth=6)  // capacity chosen between 4-10\ncenters = weighted_CVT_update(centers, quadtree)\nfor each center in centers:\n    cell = compute_power_cell(center, centers)  // lift to 3D, convex hull, then clip with Shapely\n    (new_center, new_radius) = compute_max_inscribed_circle(cell)  // use high-precision geometric functions\n    update circle center and radius\nconfiguration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nif near_feasible(configuration) and constraint_violations(configuration):\n    configuration = radial_bisection_correction(configuration)  // refine radii based on tolerance thresholds\n    configuration = SLSQP_optimize(configuration, constraints, analytic_gradients)\nreturn configuration",
      "originality": {
        "score": 8,
        "positive": "The idea integrates a diverse Sobol-based initialization with CVT-driven refinement and exact geometric correction via power diagrams, which is a novel synthesis in this context.",
        "negative": "The combination of multiple advanced modules requires careful tuning and integration, which may complicate convergence if not calibrated appropriately."
      },
      "future_potential": {
        "score": 8,
        "positive": "Its modular design allows future components such as global verification (via interval arithmetic) to be added or replaced, making it extensible to other packing and geometric optimization problems.",
        "negative": "The reliance on precise CVT and geometric computations may pose scaling challenges if extended to significantly larger or more complex instances."
      },
      "code_difficulty": {
        "score": 7,
        "positive": "The approach leverages well-established libraries (numpy, scipy, Shapely) with clear modular components, facilitating iterative improvements. The integration of analytic gradients and quadtree configurations is supported by existing tutorials and research.",
        "negative": "Integrating the CVT, power diagram extraction, analytic gradient computation, and SLSQP optimization into a single workflow demands rigorous testing, careful parameter tuning, and debugging for diverse configurations."
      }
    }
  ],
  "iteration_found": 39,
  "metrics": {
    "combined_score": 1.170771262103369,
    "runtime_seconds": 329.68,
    "sum_radii_for_n_26": 2.5860412559652857,
    "ratio_to_sota_for_n_26": 0.9810985984277123,
    "validity_for_n_26": 1.0,
    "sum_radii_for_n_27": 0.0,
    "ratio_to_sota_for_n_27": 0.0,
    "validity_for_n_27": 0.0,
    "message_for_n_27": "success",
    "sum_radii_for_n_28": 2.720523768967368,
    "ratio_to_sota_for_n_28": 0.9939801859581177,
    "validity_for_n_28": 1.0,
    "sum_radii_for_n_29": 0.0,
    "ratio_to_sota_for_n_29": 0.0,
    "validity_for_n_29": 0.0,
    "message_for_n_29": "success",
    "sum_radii_for_n_30": 0.0,
    "ratio_to_sota_for_n_30": 0.0,
    "validity_for_n_30": 0.0,
    "message_for_n_30": "success",
    "sum_radii_for_n_31": 0.0,
    "ratio_to_sota_for_n_31": 0.0,
    "validity_for_n_31": 0.0,
    "message_for_n_31": "success",
    "sum_radii_for_n_32": 2.8888338097909294,
    "ratio_to_sota_for_n_32": 0.9832839878436992,
    "validity_for_n_32": 1.0,
    "overall_validity": 0.0
  },
  "metadata": {
    "parent_metrics": {
      "combined_score": 0.41116645006567126,
      "runtime_seconds": 302.82,
      "sum_radii_for_n_26": 0.0,
      "ratio_to_sota_for_n_26": 0.0,
      "validity_for_n_26": 0.0,
      "message_for_n_26": "success",
      "sum_radii_for_n_27": 0.0,
      "ratio_to_sota_for_n_27": 0.0,
      "validity_for_n_27": 0.0,
      "message_for_n_27": "success",
      "sum_radii_for_n_28": 0.0,
      "ratio_to_sota_for_n_28": 0.0,
      "validity_for_n_28": 0.0,
      "message_for_n_28": "success",
      "sum_radii_for_n_29": 0.0,
      "ratio_to_sota_for_n_29": 0.0,
      "validity_for_n_29": 0.0,
      "message_for_n_29": "success",
      "sum_radii_for_n_30": 0.0,
      "ratio_to_sota_for_n_30": 0.0,
      "validity_for_n_30": 0.0,
      "message_for_n_30": "success",
      "sum_radii_for_n_31": 0.0,
      "ratio_to_sota_for_n_31": 0.0,
      "validity_for_n_31": 0.0,
      "message_for_n_31": "success",
      "sum_radii_for_n_32": 2.878165150459699,
      "ratio_to_sota_for_n_32": 0.9796526533388883,
      "validity_for_n_32": 1.0,
      "overall_validity": 0.0
    },
    "island": 2
  },
  "language": "python",
  "report": "In this proposal, we target the circle\u2010packing problem in a unit square for n = 26\u201332 by combining robust initialization, exact geometric refinement, and constraint\u2010sensitive optimization. Our insights emerge from the starting idea of leveraging exact power diagrams for maximum inscribed circles and SLSQP for local improvements, paired with related works that advocate diversity in initial placements (via Sobol and CVT methods), spatial acceleration (using quadtrees), and global verification using interval arithmetic. These insights suggest a multi\u2010layer algorithm that (1) generates well\u2010distributed candidate centers, (2) refines each circle\u2019s parameters via precise geometric operations, and (3) applies a constraint\u2010aware optimization to enforce non\u2010overlap and containment.\n\nThe methodology has been strengthened by explicitly addressing potential gaps: the quadtree is configured with a node capacity between 4 and 10 and a maximum depth of 5\u20136 levels, which is optimal for 26\u201332 centers; analytic gradients for non\u2010overlap and boundary constraints are computed and implemented following best practices to improve convergence. To mitigate risks of overfitting or shortcut learning, fallback mechanisms such as radial bisection correction and potential future integration of interval verification are incorporated. Every step is described with sufficient detail for reproducibility, although careful tuning of quadtree parameters, gradient implementations, and tolerance thresholds is required.\n\nOverall, while alternative ideas (e.g., pure analytic or convexification approaches) were considered, the hybrid Sobol-CVT initialization with precise power diagram refinement remains the most promising balance between novelty and ease of implementation at this early stage.",
  "code": "# === deepevolve_interface.py ===\nfrom main import construct_packing, validate_packing\nfrom time import time\nimport numpy as np\nimport traceback\nimport signal\nfrom contextlib import contextmanager\n\n\n@contextmanager\ndef timeout(duration):\n    \"\"\"Context manager for timing out function calls\"\"\"\n\n    def timeout_handler(signum, frame):\n        raise TimeoutError(f\"Function call timed out after {duration} seconds\")\n\n    # Set the signal handler\n    old_handler = signal.signal(signal.SIGALRM, timeout_handler)\n    signal.alarm(duration)\n\n    try:\n        yield\n    finally:\n        # Restore the old signal handler\n        signal.signal(signal.SIGALRM, old_handler)\n        signal.alarm(0)\n\n\ndef deepevolve_interface():\n    try:\n        start_time = time()\n\n        # SOTA values for comparison\n        sota_values = {\n            26: 2.6358627564136983,\n            27: 2.685,\n            28: 2.737,\n            29: 2.790,\n            30: 2.842,\n            31: 2.889,\n            32: 2.937944526205518,\n        }\n\n        all_results = {}\n        all_sum_radii = []\n\n        # Run for n from 26 to 32\n        for n in range(26, 33):\n            # Apply 1-minute timeout to construct_packing\n            try:\n                with timeout(60):\n                    centers, radii, sum_radii = construct_packing(n=n)\n\n                if not isinstance(centers, np.ndarray):\n                    centers = np.array(centers)\n                if not isinstance(radii, np.ndarray):\n                    radii = np.array(radii)\n\n                # Validate solution\n                valid_packing, message_packing = validate_packing(centers, radii)\n\n                if not valid_packing:\n                    print(f\"Invalid packing for n={n}: {message_packing}\")\n\n            except TimeoutError:\n                print(f\"Timeout occurred for n={n}, setting sum_radii to 0\")\n                centers = np.array([])\n                radii = np.array([])\n                sum_radii = 0.0\n                valid_packing = False\n                message_packing = f\"60s Timeout occurred for n={n}\"\n\n            # Store results\n            all_results[n] = {\n                \"sum_radii\": sum_radii if valid_packing else 0.0,\n                \"valid\": valid_packing,\n                \"message\": message_packing,\n            }\n            all_sum_radii.append(sum_radii if valid_packing else 0.0)\n\n        # Calculate runtime in seconds\n        runtime = time() - start_time\n        runtime = round(runtime, 2)\n\n        combined_score = np.mean(all_sum_radii)\n\n        metrics = {\n            \"combined_score\": combined_score,\n            \"runtime_seconds\": runtime,\n        }\n\n        # Add individual sum_radii and ratios to SOTA for each n\n        for n in range(26, 33):\n            result = all_results[n]\n            sum_radii = result[\"sum_radii\"]\n            valid = result[\"valid\"]\n\n            # Add sum_radii for this n\n            metrics[f\"sum_radii_for_n_{n}\"] = sum_radii\n\n            # Calculate ratio to SOTA\n            if n in sota_values and valid:\n                sota_value = sota_values[n]\n                ratio_to_sota = sum_radii / sota_value\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = ratio_to_sota\n            else:\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = 0.0\n\n            # Add validity for this n\n            metrics[f\"validity_for_n_{n}\"] = 1.0 if valid else 0.0\n            if not valid:\n                metrics[f\"message_for_n_{n}\"] = message_packing\n\n        overall_validity = all(all_results[n][\"valid\"] for n in range(26, 33))\n        metrics[\"overall_validity\"] = 1.0 if overall_validity else 0.0\n\n        return True, metrics\n\n    except Exception as e:\n        # Capture full traceback information\n        error_traceback = traceback.format_exc()\n        error_info = f\"\"\"\n            Error type: {type(e).__name__}\n            Error message: {str(e)}\n            Traceback: {error_traceback}\n        \"\"\"\n        return False, error_info\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    # plt.savefig('circle_packing.png')\n\n\nif __name__ == \"__main__\":\n    status, metrics = deepevolve_interface()\n    print(f\"Status: {status}\")\n    print(f\"Metrics: {metrics}\")\n    # AlphaEvolve improved this to 2.635\n\n\n# === main.py ===\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nfrom time import time\nimport traceback\nfrom scipy.optimize import minimize\n\n\ndef construct_packing(n=26):\n    \"\"\"\n    Compute circle packing for n circles in the unit square using multiple SLSQP restarts.\n    Returns:\n        centers: array of shape (n, 2)\n        radii: array of shape (n,)\n        sum_radii: float\n    \"\"\"\n    # Prebuild bounds and constraints\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    constraints = []\n\n    # Non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n\n            def overlap(x, i=i, j=j):\n                xi, yi = x[2 * i], x[2 * i + 1]\n                xj, yj = x[2 * j], x[2 * j + 1]\n                ri = x[2 * n + i]\n                rj = x[2 * n + j]\n                dist = np.hypot(xi - xj, yi - yj)\n                return dist - (ri + rj)\n\n            constraints.append({\"type\": \"ineq\", \"fun\": overlap})\n\n    # Boundary constraints\n    for i in range(n):\n\n        def left(x, i=i):\n            return x[2 * i] - x[2 * n + i]\n\n        def right(x, i=i):\n            return 1 - (x[2 * i] + x[2 * n + i])\n\n        def bottom(x, i=i):\n            return x[2 * i + 1] - x[2 * n + i]\n\n        def top(x, i=i):\n            return 1 - (x[2 * i + 1] + x[2 * n + i])\n\n        constraints.extend(\n            [\n                {\"type\": \"ineq\", \"fun\": left},\n                {\"type\": \"ineq\", \"fun\": right},\n                {\"type\": \"ineq\", \"fun\": bottom},\n                {\"type\": \"ineq\", \"fun\": top},\n            ]\n        )\n\n    best_sum = -np.inf\n    best_x = None\n\n    from scipy.stats import qmc\n\n    sampler = qmc.Sobol(d=2, scramble=True, seed=42)\n    centers0 = sampler.random(n) * 0.8 + 0.1\n    radii0 = np.full(n, 0.05)\n    centers0 = weighted_CVT_update(\n        centers0, radii0\n    )  # CVT refinement of initial centers\n    x0 = np.hstack((centers0.flatten(), radii0))\n\n    def objective(x):\n        return -np.sum(x[2 * n :])\n\n    ### >>> DEEPEVOLVE-BLOCK-START: Added analytic gradient for objective\n    def objective_jac(x):\n        jac = np.zeros_like(x)\n        jac[2 * n :] = -1\n        return jac\n\n    ### <<< DEEPEVOLVE-BLOCK-END\n\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        jac=objective_jac,\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-6},\n    )\n\n    if result.success:\n        radii = result.x[2 * n :]\n        total = np.sum(radii)\n        if total > best_sum:\n            best_sum = total\n            best_x = result.x.copy()\n\n    if best_x is None:\n        return [], [], 0.0\n\n    centers = best_x[: 2 * n].reshape(n, 2)\n    radii = best_x[2 * n :]\n\n    # Iterative refinement using power diagram and maximum inscribed circles\n    for _ in range(10):\n        cells = compute_power_cells(centers, radii)\n        new_centers = []\n        new_radii = []\n        for i, cell in enumerate(cells):\n            if cell.is_empty:\n                new_centers.append(centers[i])\n                new_radii.append(radii[i] * 0.9)\n            else:\n                point, r_val = find_max_inscribed_circle(cell, resolution=0.002)\n                if point is None:\n                    new_centers.append(centers[i])\n                    new_radii.append(radii[i])\n                else:\n                    new_centers.append([point.x, point.y])\n                    new_radii.append(min(r_val, radii[i] + 0.001))\n        new_centers = np.array(new_centers)\n        new_radii = np.array(new_radii)\n        if (\n            np.linalg.norm(new_centers - centers) < 1e-4\n            and np.linalg.norm(new_radii - radii) < 1e-4\n        ):\n            centers, radii = new_centers, new_radii\n            break\n        centers, radii = new_centers, new_radii\n\n    # Final refinement with SLSQP to enforce non-overlap and boundary constraints\n    x0 = np.hstack((centers.flatten(), radii))\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        jac=objective_jac,\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-8},\n    )\n    if result.success:\n        radii = result.x[2 * n :]\n        centers = result.x[: 2 * n].reshape(n, 2)\n        best_sum = np.sum(radii)\n        ### >>> DEEPEVOLVE-BLOCK-START: Adaptive bisection correction for near-feasible configurations\n        valid, msg = validate_packing(centers, radii)\n        if not valid:\n            new_radii = adaptive_bisection(centers, radii)\n            x0 = np.hstack((centers.flatten(), new_radii))\n            result_refined = minimize(\n                objective,\n                x0,\n                method=\"SLSQP\",\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=constraints,\n                options={\"maxiter\": 1000, \"ftol\": 1e-8},\n            )\n            if result_refined.success:\n                radii = result_refined.x[2 * n :]\n                centers = result_refined.x[: 2 * n].reshape(n, 2)\n                best_sum = np.sum(radii)\n        ### <<< DEEPEVOLVE-BLOCK-END\n\n    return centers, radii, best_sum\n\n\n# DEBUG: added missing compute_power_cells and find_max_inscribed_circle implementations\n### <<< DEEPEVOLVE-BLOCK-END\nfrom shapely.geometry import Polygon, Point, LineString\nfrom shapely.ops import split\n\n\ndef compute_power_cells(centers, radii):\n    \"\"\"\n    Compute power cells (weighted Voronoi) for given centers and radii inside the unit square.\n    Returns a list of shapely Polygon objects representing each cell.\n    \"\"\"\n    # build a large bounding box for half\u2010space intersections\n    M = 10.0\n    bb = Polygon([(-M, -M), (M, -M), (M, M), (-M, M)])\n    # start from the unit square\n    domain = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n    cells = []\n    n = len(centers)\n    for i in range(n):\n        poly = domain\n        cx_i, cy_i = centers[i]\n        weight_i = cx_i * cx_i + cy_i * cy_i - radii[i] * radii[i]\n        for j in range(n):\n            if j == i:\n                continue\n            cx_j, cy_j = centers[j]\n            weight_j = cx_j * cx_j + cy_j * cy_j - radii[j] * radii[j]\n            # half\u2010space: 2*(c_j - c_i)\u22c5x <= weight_j - weight_i\n            a = 2 * (cx_j - cx_i)\n            b = 2 * (cy_j - cy_i)\n            c = weight_j - weight_i\n            # build splitting line across the big box\n            if abs(b) > abs(a) and b != 0:\n                p1 = Point(-M, (c - a * (-M)) / b)\n                p2 = Point(M, (c - a * (M)) / b)\n            else:\n                # vertical line (avoid division by zero)\n                if a == 0:\n                    poly = Polygon()\n                    break\n                p1 = Point(c / a, -M)\n                p2 = Point(c / a, M)\n            line = LineString([p1, p2])\n            # split the bounding box into two half\u2010spaces\n            # DEBUG: shapely.ops.split returns a GeometryCollection, which is not directly iterable; iterate over pieces.geoms\n            pieces = split(bb, line)\n            halfspace = None\n            for piece in pieces.geoms:\n                test_pt = piece.representative_point()\n                if a * test_pt.x + b * test_pt.y <= c:\n                    halfspace = piece\n                    break\n            if halfspace is None:\n                poly = Polygon()\n                break\n            poly = poly.intersection(halfspace)\n            if poly.is_empty:\n                break\n        cells.append(poly)\n    return cells\n\n\n### >>> DEEPEVOLVE-BLOCK-START: Optimize grid sampling in find_max_inscribed_circle using np.arange\ndef find_max_inscribed_circle(polygon, resolution=0.002):\n    \"\"\"\n    Approximate the maximum inscribed circle in a polygon by grid sampling.\n    Returns (Point center, radius) or (None, 0) if the polygon is empty.\n    \"\"\"\n    from shapely.geometry import Point\n\n    if polygon.is_empty:\n        return None, 0.0\n    minx, miny, maxx, maxy = polygon.bounds\n    best_pt = None\n    best_r = 0.0\n    import numpy as np\n\n    xs = np.arange(minx, maxx + resolution, resolution)\n    ys = np.arange(miny, maxy + resolution, resolution)\n    for x in xs:\n        for y in ys:\n            pt = Point(x, y)\n            if polygon.contains(pt):\n                d = polygon.boundary.distance(pt)\n                if d > best_r:\n                    best_r = d\n                    best_pt = pt\n    if best_pt is None:\n        return None, 0.0\n    return best_pt, best_r\n\n\n### <<< DEEPEVOLVE-BLOCK-END\n\n\n### >>> DEEPEVOLVE-BLOCK-START: Add weighted_CVT_update for CVT refinement of centers\ndef weighted_CVT_update(centers, radii, iterations=5):\n    \"\"\"\n    Refine centers using weighted Centroidal Voronoi Tessellation.\n    \"\"\"\n    import numpy as np\n\n    for _ in range(iterations):\n        cells = compute_power_cells(centers, radii)\n        new_centers = []\n        for cell, center in zip(cells, centers):\n            if not cell.is_empty:\n                new_centers.append([cell.centroid.x, cell.centroid.y])\n            else:\n                new_centers.append(center)\n        new_centers = np.array(new_centers)\n        if np.linalg.norm(new_centers - centers) < 1e-4:\n            break\n        centers = new_centers\n    return centers\n\n\n### <<< DEEPEVOLVE-BLOCK-END\ndef validate_packing(centers, radii):\n    \"\"\"\n    Validate that circles don't overlap and are inside the unit square\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    n = centers.shape[0]\n\n    # Check if circles are inside the unit square with tolerance\n    tol = 1e-6\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if (x - r < -tol) or (x + r > 1 + tol) or (y - r < -tol) or (y + r > 1 + tol):\n            message = (\n                f\"Circle {i} at ({x}, {y}) with radius {r} is outside the unit square\"\n            )\n            return False, message\n\n    # Check for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if dist < radii[i] + radii[j]:\n                message = f\"Circles {i} and {j} overlap: dist={dist}, r1+r2={radii[i]+radii[j]}\"\n                return False, message\n\n    # DEBUG: Retained return and added adaptive_bisection for near-feasible corrections via bisection scaling\n    return True, \"success\"\n\n\ndef adaptive_bisection(centers, radii, tol=1e-6, max_iter=20):\n    \"\"\"\n    Adaptive bisection correction: scale radii to satisfy non-overlap and boundary constraints.\n    \"\"\"\n    import numpy as np\n\n    low, high = 0.0, 1.0\n    best = radii * 0.0\n    for _ in range(max_iter):\n        mid = (low + high) / 2\n        scaled = radii * mid\n        valid, _ = validate_packing(centers, scaled)\n        if valid:\n            best = scaled\n            low = mid\n        else:\n            high = mid\n        if (high - low) < tol:\n            break\n    return best\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = construct_packing(n=28)\n    print(\"centers\", centers)\n    print(\"radii\", radii)\n    print(\"sum_radii\", sum_radii)\n\n    valid_packing, message_packing = validate_packing(centers, radii)\n    print(\"valid_packing\", valid_packing)\n    print(\"message_packing\", message_packing)\n\n    # visualize(centers, radii)\n"
}