{
  "id": "58af2a81-381b-437a-9e13-e0a8fc29e4ed",
  "idea": {
    "description": "Quadtree-CVT Hybrid Initialization with Adaptive Jamming and SLSQP Refinement",
    "motivation": "By integrating a quadtree-partitioned Sobol-based initialization with a weighted CVT refinement, this approach better distributes candidate circle centers while ensuring efficient spatial querying. Exact geometric refinement via power diagrams and Shapely guarantees each circle is optimally sized, and SLSQP optimization with adaptive jamming and explicit radial bisection steps (complete with tolerance thresholds and stopping criteria) ensures rigorous feasibility and minimizes risks of overfitting or shortcut learning.",
    "implementation_notes": "\u2022 Use a scrambled Sobol sequence to generate initial centers.\n\u2022 Build a quadtree to partition the unit square, improving the efficiency of local neighborhood searches.\n\u2022 Perform a weighted CVT step: update each center to the weighted centroid of its corresponding Voronoi cell; consult reference implementations (e.g., MATLAB's CVT_2D_SAMPLING) for details on weighted centroid computation.\n\u2022 Compute the power diagram by lifting points to 3D (using x\u00b2 + y\u00b2 - weight) and extracting the lower faces with SciPy's ConvexHull, then clip cells to the unit square using Shapely.\n\u2022 For each clipped cell, compute the Maximum Inscribed Circle (MIC) to update circle centers and radii.\n\u2022 Optimize the configuration using SciPy's SLSQP with analytic gradients for the non-overlap and boundary constraints.\n\u2022 If the solution is near-feasible but violations persist, employ an adaptive radial bisection correction on the radii. Establish initial bounds based on circle contact distances and calculate iteration requirements using (ln|b - a| - ln \u03b5)/ln2. Use stopping criteria based on interval length, consecutive midpoint differences, or the function value at the midpoint.\n\u2022 Log intermediate configurations to assist in reproducibility and fine-tuning of parameters.",
    "pseudocode": "centers = generate_sobol_points(n)\nsubregions = quadtree_partition(unit_square, adaptive=True)\ncenters = perform_CVT(centers, subregions, weighted=True)\nfor center in centers:\n    cell = compute_power_cell(center, centers)  // Lift to 3D and use ConvexHull; clip with Shapely\n    (new_center, new_radius) = max_inscribed_circle(cell)\n    update candidate with new_center and new_radius\ncandidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\nif not verify(candidate):\n    candidate.radii = radial_bisection_correction(candidate.radii)  // using defined initial bounds, tolerance, and stopping criteria\n    candidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\nreturn candidate",
    "originality": {
      "score": 8,
      "positive": "Innovatively fuses quadtree partitioning, weighted CVT, and exact power diagram analysis with robust SLSQP optimization and adaptive correction. The explicit incorporation of a well-documented radial bisection routine strengthens its novelty.",
      "negative": "Requires careful calibration of the quadtree, CVT parameters, and bisection thresholds, which introduces complexity in early-stage prototypes."
    },
    "future_potential": {
      "score": 8,
      "positive": "The modular design enables adaptation to other nonconvex geometric packing problems and supports incremental improvements, providing a robust baseline for future research.",
      "negative": "Empirical tuning of spatial partitioning and bisection parameters may be required, potentially limiting immediate generalization across different instance sizes."
    },
    "code_difficulty": {
      "score": 7,
      "positive": "Utilizes standard Python libraries (numpy, scipy, Shapely) and modular components that facilitate debugging and iterative development.",
      "negative": "Integrates multiple advanced geometric and optimization techniques, necessitating rigorous testing and careful parameter calibration, which increases development complexity."
    }
  },
  "timestamp": 1750149751.596248,
  "parent_id": "af834fdc-51f2-4d0c-8820-d597693a92b9",
  "evolution_history": [
    {
      "description": "A hybrid algorithm that integrates exact power diagram calculation with iterative refinement. The method starts by seeding circle centers, then computes an exact weighted Voronoi (power) diagram using the transformation of weighted points and 3D convex hull. It updates each circle's parameters by calculating the maximum inscribed circle within each power cell (using Shapely with precision settings) and refines the configuration using SLSQP with robust non-overlap constraints.",
      "motivation": "This approach leverages an exact geometric partitioning method to produce high-quality initial conditions, while overcoming the inaccuracy of pure numerical optimization. It ensures valid packings by combining exact power diagram computations and rigorous geometric verification, essential for advancing early-stage research on circle packing in a unit square.",
      "implementation_notes": "Implement using numpy for vectorized operations, scipy.spatial.ConvexHull for exact power diagram extraction (via transforming points to 3D), and Shapely for robust geometric checks (set_precision, buffering, and tolerance-based distance comparisons). Develop a loop that updates centers and radii iteratively and refines the configuration with SLSQP under strict non-overlap and containment constraints, referencing benchmark packings for n=26 to 32.",
      "pseudocode": "initialize centers and radii; while not converged:\n    transform centers to weighted points: (x, y, x^2+y^2-r^2);\n    compute 3D convex hull; extract lower faces to form power diagram; \n    for each power cell:\n         extract polygon vertices; \n         compute centroid and maximum inscribed circle (using Shapely with fixed precision);\n    update centers and radii; \n    refine via SLSQP with non-overlap and boundary constraints; \n    validate using Shapely (distance checks and buffers); \nreturn optimal packing",
      "originality": {
        "score": 6,
        "positive": "It creatively integrates exact power diagram computation (using a 3D convex hull method) with iterative numerical refinement, which is a novel combination for this circle packing problem.",
        "negative": "The idea builds partially on established methods; careful implementation is required to manage the complexity and numerical precision."
      },
      "future_potential": {
        "score": 8,
        "positive": "The method is scalable to other packing problems and can be further refined with advanced verification techniques, providing a rich ground for future research.",
        "negative": "Incremental improvements may be needed to ensure global optimality beyond local refinements."
      },
      "code_difficulty": {
        "score": 6,
        "positive": "The algorithm is implementable with available Python libraries and modular steps, allowing iterative improvements and integration of robust geometric operations.",
        "negative": "Implementing an exact power diagram and handling precision with Shapely increases the complexity compared to a basic SLSQP approach."
      }
    },
    {
      "description": "Quadtree-CVT Hybrid Initialization with Adaptive Jamming and SLSQP Refinement",
      "motivation": "By integrating a quadtree-partitioned Sobol-based initialization with a weighted CVT refinement, this approach better distributes candidate circle centers while ensuring efficient spatial querying. Exact geometric refinement via power diagrams and Shapely guarantees each circle is optimally sized, and SLSQP optimization with adaptive jamming and explicit radial bisection steps (complete with tolerance thresholds and stopping criteria) ensures rigorous feasibility and minimizes risks of overfitting or shortcut learning.",
      "implementation_notes": "\u2022 Use a scrambled Sobol sequence to generate initial centers.\n\u2022 Build a quadtree to partition the unit square, improving the efficiency of local neighborhood searches.\n\u2022 Perform a weighted CVT step: update each center to the weighted centroid of its corresponding Voronoi cell; consult reference implementations (e.g., MATLAB's CVT_2D_SAMPLING) for details on weighted centroid computation.\n\u2022 Compute the power diagram by lifting points to 3D (using x\u00b2 + y\u00b2 - weight) and extracting the lower faces with SciPy's ConvexHull, then clip cells to the unit square using Shapely.\n\u2022 For each clipped cell, compute the Maximum Inscribed Circle (MIC) to update circle centers and radii.\n\u2022 Optimize the configuration using SciPy's SLSQP with analytic gradients for the non-overlap and boundary constraints.\n\u2022 If the solution is near-feasible but violations persist, employ an adaptive radial bisection correction on the radii. Establish initial bounds based on circle contact distances and calculate iteration requirements using (ln|b - a| - ln \u03b5)/ln2. Use stopping criteria based on interval length, consecutive midpoint differences, or the function value at the midpoint.\n\u2022 Log intermediate configurations to assist in reproducibility and fine-tuning of parameters.",
      "pseudocode": "centers = generate_sobol_points(n)\nsubregions = quadtree_partition(unit_square, adaptive=True)\ncenters = perform_CVT(centers, subregions, weighted=True)\nfor center in centers:\n    cell = compute_power_cell(center, centers)  // Lift to 3D and use ConvexHull; clip with Shapely\n    (new_center, new_radius) = max_inscribed_circle(cell)\n    update candidate with new_center and new_radius\ncandidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\nif not verify(candidate):\n    candidate.radii = radial_bisection_correction(candidate.radii)  // using defined initial bounds, tolerance, and stopping criteria\n    candidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\nreturn candidate",
      "originality": {
        "score": 8,
        "positive": "Innovatively fuses quadtree partitioning, weighted CVT, and exact power diagram analysis with robust SLSQP optimization and adaptive correction. The explicit incorporation of a well-documented radial bisection routine strengthens its novelty.",
        "negative": "Requires careful calibration of the quadtree, CVT parameters, and bisection thresholds, which introduces complexity in early-stage prototypes."
      },
      "future_potential": {
        "score": 8,
        "positive": "The modular design enables adaptation to other nonconvex geometric packing problems and supports incremental improvements, providing a robust baseline for future research.",
        "negative": "Empirical tuning of spatial partitioning and bisection parameters may be required, potentially limiting immediate generalization across different instance sizes."
      },
      "code_difficulty": {
        "score": 7,
        "positive": "Utilizes standard Python libraries (numpy, scipy, Shapely) and modular components that facilitate debugging and iterative development.",
        "negative": "Integrates multiple advanced geometric and optimization techniques, necessitating rigorous testing and careful parameter calibration, which increases development complexity."
      }
    }
  ],
  "iteration_found": 37,
  "metrics": {
    "combined_score": 1.1697961404336428,
    "runtime_seconds": 300.84,
    "sum_radii_for_n_26": 2.6195161665427085,
    "ratio_to_sota_for_n_26": 0.9937983911221423,
    "validity_for_n_26": 1.0,
    "sum_radii_for_n_27": 2.6777934784965867,
    "ratio_to_sota_for_n_27": 0.997316006888859,
    "validity_for_n_27": 1.0,
    "sum_radii_for_n_28": 0.0,
    "ratio_to_sota_for_n_28": 0.0,
    "validity_for_n_28": 0.0,
    "message_for_n_28": "success",
    "sum_radii_for_n_29": 0.0,
    "ratio_to_sota_for_n_29": 0.0,
    "validity_for_n_29": 0.0,
    "message_for_n_29": "success",
    "sum_radii_for_n_30": 0.0,
    "ratio_to_sota_for_n_30": 0.0,
    "validity_for_n_30": 0.0,
    "message_for_n_30": "success",
    "sum_radii_for_n_31": 0.0,
    "ratio_to_sota_for_n_31": 0.0,
    "validity_for_n_31": 0.0,
    "message_for_n_31": "success",
    "sum_radii_for_n_32": 2.891263337996204,
    "ratio_to_sota_for_n_32": 0.9841109361347932,
    "validity_for_n_32": 1.0,
    "overall_validity": 0.0
  },
  "metadata": {
    "parent_metrics": {
      "combined_score": 0.41116645006567126,
      "runtime_seconds": 302.82,
      "sum_radii_for_n_26": 0.0,
      "ratio_to_sota_for_n_26": 0.0,
      "validity_for_n_26": 0.0,
      "message_for_n_26": "success",
      "sum_radii_for_n_27": 0.0,
      "ratio_to_sota_for_n_27": 0.0,
      "validity_for_n_27": 0.0,
      "message_for_n_27": "success",
      "sum_radii_for_n_28": 0.0,
      "ratio_to_sota_for_n_28": 0.0,
      "validity_for_n_28": 0.0,
      "message_for_n_28": "success",
      "sum_radii_for_n_29": 0.0,
      "ratio_to_sota_for_n_29": 0.0,
      "validity_for_n_29": 0.0,
      "message_for_n_29": "success",
      "sum_radii_for_n_30": 0.0,
      "ratio_to_sota_for_n_30": 0.0,
      "validity_for_n_30": 0.0,
      "message_for_n_30": "success",
      "sum_radii_for_n_31": 0.0,
      "ratio_to_sota_for_n_31": 0.0,
      "validity_for_n_31": 0.0,
      "message_for_n_31": "success",
      "sum_radii_for_n_32": 2.878165150459699,
      "ratio_to_sota_for_n_32": 0.9796526533388883,
      "validity_for_n_32": 1.0,
      "overall_validity": 0.0
    },
    "island": 2
  },
  "language": "python",
  "report": "### Synthesis of Insights and Proposed Directions\n\n**Insights from the Starting Idea:**\n1. The use of an exact power diagram (via 3D convex hull transformation) provides a precise means to compute the maximum inscribed circle within each cell, enforcing rigorous geometric feasibility. This is central to ensuring each circle is maximized in size while remaining valid.\n2. Iterative refinement with SLSQP optimization facilitates fine-tuning of circle centers and radii under exact non\u2010overlap and boundary constraints, leveraging analytic gradients for efficiency.\n3. Seeding with low-discrepancy sequences (like Sobol) ensures a uniform initial distribution, which is critical in avoiding local clustering in the unit square.\n\n**Insights from Related Works and Inspirations:**\n1. Incorporating quadtree-based spatial indexing can greatly speed up overlap detection and assist in local adjustments, as shown in several inspirations. This spatial partitioning minimizes unnecessary computations in global optimizations.\n2. Hybridization with Centroidal Voronoi Tessellation (CVT) steps or weighted CVT not only addresses non-uniform density issues but also positions circle centers closer to cell centroids for more natural packings.\n3. Adaptive jamming and radial bisection methods offer robust strategies to correct near-violations in feasibility, ensuring exact packings with guaranteed separation.\n\n**Organized Research Directions:**\n1. **Robust Initialization:** Combine Sobol sequences with quadtree partitioning and a CVT pass to generate well-distributed, density-aware candidate centers.\n2. **Exact Geometric Refinement:** Utilize precise power diagram and Shapely-based maximum inscribed circle computation to update circle parameters.\n3. **Adaptive Optimization:** Integrate SLSQP with analytical gradients and include adaptive jamming/bisection steps to iteratively rectify overlaps or boundary issues.\n\n**Structured Framework:**\nA conceptual map emerges where initialization (Sobol + quadtree + CVT) feeds into a geometric module (power diagram, MIC via Shapely), which then interfaces with a continuous optimization stage (SLSQP + adaptive corrections). This pipeline clearly delineates modules that ensure both global planning and local exactness, while explicitly incorporating proper bounds, tolerance thresholds, and stopping criteria for the radial bisection process to counter any overfitting or shortcut learning risks.\n\n**Generated Algorithmic Ideas & Evaluation:**\n1. *Pure Power Diagram-SLSQP Pipeline* \u2013 Originality: 7, Future Potential: 7, Code Difficulty: 6.\n2. *Quadtree-Enhanced Sobol with Adaptive Jamming* \u2013 Originality: 8, Future Potential: 8, Code Difficulty: 7.\n3. *Quadtree-CVT Hybrid Initialization with Adaptive Jamming and SLSQP Refinement* \u2013 Originality: 8, Future Potential: 8, Code Difficulty: 7.\n\n**Chosen Idea:**\nThe best idea for our early-stage 10% progress is the *Quadtree-CVT Hybrid Initialization with Adaptive Jamming and SLSQP Refinement*. Its modular integration of proven techniques addresses both global distribution and local geometric precision. With clear references to radial bisection techniques (including initial bounds, tolerance thresholds, and stopping criteria), it minimizes the risks of overfitting and shortcut learning.\n\n**Rationale & Pseudocode:**\n- **Rationale:** The algorithm starts by generating candidate centers using a scrambled Sobol sequence. A quadtree organizes the candidates spatially, and a weighted CVT step repositions centers to the local centroids, improving uniformity. An exact power diagram is then computed (using 3D convex hull methods and Shapely for clipping) to determine the maximum inscribed circle for each cell. Finally, SLSQP optimization refines the configuration under strict non-overlap and boundary constraints, while adaptive radial bisection\u2014with clearly defined tolerance thresholds and stopping criteria\u2014is applied when near-feasible solutions show margin violations.\n\n- **Pseudocode:**\n  \u2022 centers = generate_sobol_points(n)\n  \u2022 subregions = quadtree_partition(unit_square, adaptive=True)\n  \u2022 centers = perform_CVT(centers, subregions, weighted=True)\n  \u2022 For each center:\n      - Compute power cell using 3D lifting and clip via Shapely\n      - (center, radius) = max_inscribed_circle(cell)\n      - Update candidate with new center and radius\n  \u2022 candidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\n  \u2022 If verification fails:\n      - candidate.radii = radial_bisection_correction(candidate.radii)  // using defined initial bounds, tolerance thresholds (e.g. n > (ln|b-a| - ln \u03b5)/ln2), and stopping criteria (interval length, consecutive midpoint difference, or function value)\n      - candidate = SLSQP_optimize(candidate, analytic_gradients, constraints)\n  \u2022 Return best_candidate",
  "code": "# === deepevolve_interface.py ===\nfrom main import construct_packing, validate_packing\nfrom time import time\nimport numpy as np\nimport traceback\nimport signal\nfrom contextlib import contextmanager\n\n\n@contextmanager\ndef timeout(duration):\n    \"\"\"Context manager for timing out function calls\"\"\"\n\n    def timeout_handler(signum, frame):\n        raise TimeoutError(f\"Function call timed out after {duration} seconds\")\n\n    # Set the signal handler\n    old_handler = signal.signal(signal.SIGALRM, timeout_handler)\n    signal.alarm(duration)\n\n    try:\n        yield\n    finally:\n        # Restore the old signal handler\n        signal.signal(signal.SIGALRM, old_handler)\n        signal.alarm(0)\n\n\ndef deepevolve_interface():\n    try:\n        start_time = time()\n\n        # SOTA values for comparison\n        sota_values = {\n            26: 2.6358627564136983,\n            27: 2.685,\n            28: 2.737,\n            29: 2.790,\n            30: 2.842,\n            31: 2.889,\n            32: 2.937944526205518,\n        }\n\n        all_results = {}\n        all_sum_radii = []\n\n        # Run for n from 26 to 32\n        for n in range(26, 33):\n            # Apply 1-minute timeout to construct_packing\n            try:\n                with timeout(60):\n                    centers, radii, sum_radii = construct_packing(n=n)\n\n                if not isinstance(centers, np.ndarray):\n                    centers = np.array(centers)\n                if not isinstance(radii, np.ndarray):\n                    radii = np.array(radii)\n\n                # Validate solution\n                valid_packing, message_packing = validate_packing(centers, radii)\n\n                if not valid_packing:\n                    print(f\"Invalid packing for n={n}: {message_packing}\")\n\n            except TimeoutError:\n                print(f\"Timeout occurred for n={n}, setting sum_radii to 0\")\n                centers = np.array([])\n                radii = np.array([])\n                sum_radii = 0.0\n                valid_packing = False\n                message_packing = f\"60s Timeout occurred for n={n}\"\n\n            # Store results\n            all_results[n] = {\n                \"sum_radii\": sum_radii if valid_packing else 0.0,\n                \"valid\": valid_packing,\n                \"message\": message_packing,\n            }\n            all_sum_radii.append(sum_radii if valid_packing else 0.0)\n\n        # Calculate runtime in seconds\n        runtime = time() - start_time\n        runtime = round(runtime, 2)\n\n        combined_score = np.mean(all_sum_radii)\n\n        metrics = {\n            \"combined_score\": combined_score,\n            \"runtime_seconds\": runtime,\n        }\n\n        # Add individual sum_radii and ratios to SOTA for each n\n        for n in range(26, 33):\n            result = all_results[n]\n            sum_radii = result[\"sum_radii\"]\n            valid = result[\"valid\"]\n\n            # Add sum_radii for this n\n            metrics[f\"sum_radii_for_n_{n}\"] = sum_radii\n\n            # Calculate ratio to SOTA\n            if n in sota_values and valid:\n                sota_value = sota_values[n]\n                ratio_to_sota = sum_radii / sota_value\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = ratio_to_sota\n            else:\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = 0.0\n\n            # Add validity for this n\n            metrics[f\"validity_for_n_{n}\"] = 1.0 if valid else 0.0\n            if not valid:\n                metrics[f\"message_for_n_{n}\"] = message_packing\n\n        overall_validity = all(all_results[n][\"valid\"] for n in range(26, 33))\n        metrics[\"overall_validity\"] = 1.0 if overall_validity else 0.0\n\n        return True, metrics\n\n    except Exception as e:\n        # Capture full traceback information\n        error_traceback = traceback.format_exc()\n        error_info = f\"\"\"\n            Error type: {type(e).__name__}\n            Error message: {str(e)}\n            Traceback: {error_traceback}\n        \"\"\"\n        return False, error_info\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    # plt.savefig('circle_packing.png')\n\n\nif __name__ == \"__main__\":\n    status, metrics = deepevolve_interface()\n    print(f\"Status: {status}\")\n    print(f\"Metrics: {metrics}\")\n    # AlphaEvolve improved this to 2.635\n\n\n# === main.py ===\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nfrom time import time\nimport traceback\nfrom scipy.optimize import minimize\n\n# DEBUG: added missing compute_CVT function for CVT initialization\nfrom scipy.spatial import Voronoi\nfrom shapely.geometry import Polygon\n\n\ndef compute_CVT(centers, iterations=3):\n    \"\"\"\n    Perform simple CVT initialization: iteratively move centers to centroids of their Voronoi cells clipped to the unit square.\n    Args:\n        centers: np.ndarray of shape (n,2)\n        iterations: int number of iterations\n    Returns:\n        np.ndarray of updated centers of shape (n,2)\n    \"\"\"\n    # define unit square domain for clipping\n    domain = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n    for _ in range(iterations):\n        vor = Voronoi(centers)\n        new_centers = []\n        for i, _ in enumerate(centers):\n            region_index = vor.point_region[i]\n            region = vor.regions[region_index]\n            if not region or -1 in region:\n                # unbounded or invalid region; keep original\n                new_centers.append(centers[i])\n            else:\n                poly = Polygon([vor.vertices[j] for j in region])\n                clipped = poly.intersection(domain)\n                if clipped.is_empty:\n                    new_centers.append(centers[i])\n                else:\n                    centroid = clipped.centroid\n                    new_centers.append([centroid.x, centroid.y])\n        centers = np.array(new_centers)\n    return centers\n\n\ndef construct_packing(n=26):\n    \"\"\"\n    Compute circle packing for n circles in the unit square using multiple SLSQP restarts.\n    Returns:\n        centers: array of shape (n, 2)\n        radii: array of shape (n,)\n        sum_radii: float\n    \"\"\"\n    # Prebuild bounds and constraints\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    constraints = []\n\n    # Non-overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n\n            def overlap(x, i=i, j=j):\n                xi, yi = x[2 * i], x[2 * i + 1]\n                xj, yj = x[2 * j], x[2 * j + 1]\n                ri = x[2 * n + i]\n                rj = x[2 * n + j]\n                dist = np.hypot(xi - xj, yi - yj)\n                return dist - (ri + rj)\n\n            constraints.append({\"type\": \"ineq\", \"fun\": overlap})\n\n    # Boundary constraints\n    for i in range(n):\n\n        def left(x, i=i):\n            return x[2 * i] - x[2 * n + i]\n\n        def right(x, i=i):\n            return 1 - (x[2 * i] + x[2 * n + i])\n\n        def bottom(x, i=i):\n            return x[2 * i + 1] - x[2 * n + i]\n\n        def top(x, i=i):\n            return 1 - (x[2 * i + 1] + x[2 * n + i])\n\n        constraints.extend(\n            [\n                {\"type\": \"ineq\", \"fun\": left},\n                {\"type\": \"ineq\", \"fun\": right},\n                {\"type\": \"ineq\", \"fun\": bottom},\n                {\"type\": \"ineq\", \"fun\": top},\n            ]\n        )\n\n    best_sum = -np.inf\n    best_x = None\n\n    from scipy.stats import qmc\n\n    sampler = qmc.Sobol(d=2, scramble=True, seed=42)\n    centers0 = sampler.random(n)\n    centers0 = compute_CVT(centers0, iterations=3)\n    centers0 = np.clip(\n        centers0, 0, 1\n    )  # Ensure centers remain strictly within the unit square\n    radii0 = np.full(n, 0.05)\n    x0 = np.hstack((centers0.flatten(), radii0))\n\n    def objective(x):\n        return -np.sum(x[2 * n :])\n\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-6},\n    )\n\n    if result.success:\n        radii = result.x[2 * n :]\n        total = np.sum(radii)\n        if total > best_sum:\n            best_sum = total\n            best_x = result.x.copy()\n\n    if best_x is None:\n        return [], [], 0.0\n\n    centers = best_x[: 2 * n].reshape(n, 2)\n    radii = best_x[2 * n :]\n\n    # Iterative refinement using power diagram and maximum inscribed circles\n    for _ in range(10):\n        cells = compute_power_cells(centers, radii)\n        new_centers = []\n        new_radii = []\n        for i, cell in enumerate(cells):\n            if cell.is_empty:\n                new_centers.append(centers[i])\n                new_radii.append(radii[i] * 0.9)\n            else:\n                point, r_val = find_max_inscribed_circle(cell, resolution=0.002)\n                if point is None:\n                    new_centers.append(centers[i])\n                    new_radii.append(radii[i])\n                else:\n                    new_centers.append([point.x, point.y])\n                    new_radii.append(min(r_val, radii[i] + 0.001))\n        new_centers = np.array(new_centers)\n        new_radii = np.array(new_radii)\n        if (\n            np.linalg.norm(new_centers - centers) < 1e-4\n            and np.linalg.norm(new_radii - radii) < 1e-4\n        ):\n            centers, radii = new_centers, new_radii\n            break\n        centers, radii = new_centers, new_radii\n\n    # Final refinement with SLSQP to enforce non-overlap and boundary constraints\n    x0 = np.hstack((centers.flatten(), radii))\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-8},\n    )\n    if result.success:\n        radii = result.x[2 * n :]\n        centers = result.x[: 2 * n].reshape(n, 2)\n        best_sum = np.sum(radii)\n        valid, msg = validate_packing(centers, radii)\n        if not valid:\n            # Adaptive bisection: shrink radii until a valid configuration is reached\n            radii = adaptive_bisection(centers, radii)\n            x0 = np.hstack((centers.flatten(), radii))\n            result = minimize(\n                objective,\n                x0,\n                method=\"SLSQP\",\n                bounds=bounds,\n                constraints=constraints,\n                options={\"maxiter\": 1000, \"ftol\": 1e-8},\n            )\n            if result.success:\n                radii = result.x[2 * n :]\n                centers = result.x[: 2 * n].reshape(n, 2)\n                best_sum = np.sum(radii)\n    ### <<< DEEPEVOLVE-BLOCK-END\n\n    return centers, radii, best_sum\n\n\n# DEBUG: added missing compute_power_cells and find_max_inscribed_circle implementations\n### <<< DEEPEVOLVE-BLOCK-END\nfrom shapely.geometry import Polygon, Point, LineString\nfrom shapely.ops import split\n\n\ndef compute_power_cells(centers, radii):\n    \"\"\"\n    Compute power cells (weighted Voronoi) for given centers and radii inside the unit square.\n    Returns a list of shapely Polygon objects representing each cell.\n    \"\"\"\n    # build a large bounding box for half\u2010space intersections\n    M = 10.0\n    bb = Polygon([(-M, -M), (M, -M), (M, M), (-M, M)])\n    # start from the unit square\n    domain = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n    cells = []\n    n = len(centers)\n    for i in range(n):\n        poly = domain\n        cx_i, cy_i = centers[i]\n        weight_i = cx_i * cx_i + cy_i * cy_i - radii[i] * radii[i]\n        for j in range(n):\n            if j == i:\n                continue\n            cx_j, cy_j = centers[j]\n            weight_j = cx_j * cx_j + cy_j * cy_j - radii[j] * radii[j]\n            # half\u2010space: 2*(c_j - c_i)\u22c5x <= weight_j - weight_i\n            a = 2 * (cx_j - cx_i)\n            b = 2 * (cy_j - cy_i)\n            c = weight_j - weight_i\n            # build splitting line across the big box\n            if abs(b) > abs(a) and b != 0:\n                p1 = Point(-M, (c - a * (-M)) / b)\n                p2 = Point(M, (c - a * (M)) / b)\n            else:\n                # vertical line (avoid division by zero)\n                if a == 0:\n                    poly = Polygon()\n                    break\n                p1 = Point(c / a, -M)\n                p2 = Point(c / a, M)\n            line = LineString([p1, p2])\n            # split the bounding box into two half\u2010spaces\n            # DEBUG: shapely.ops.split returns a GeometryCollection, which is not directly iterable; iterate over pieces.geoms\n            pieces = split(bb, line)\n            halfspace = None\n            for piece in pieces.geoms:\n                test_pt = piece.representative_point()\n                if a * test_pt.x + b * test_pt.y <= c:\n                    halfspace = piece\n                    break\n            if halfspace is None:\n                poly = Polygon()\n                break\n            poly = poly.intersection(halfspace)\n            if poly.is_empty:\n                break\n        cells.append(poly)\n    return cells\n\n\ndef find_max_inscribed_circle(polygon, resolution=0.002):\n    \"\"\"\n    Approximate the maximum inscribed circle in a polygon by grid sampling.\n    Returns (Point center, radius) or (None, 0) if the polygon is empty.\n    \"\"\"\n    if polygon.is_empty:\n        return None, 0.0\n    minx, miny, maxx, maxy = polygon.bounds\n    best_pt = None\n    best_r = 0.0\n    x = minx\n    while x <= maxx:\n        y = miny\n        while y <= maxy:\n            pt = Point(x, y)\n            if polygon.contains(pt):\n                # distance to the boundary\n                d = polygon.boundary.distance(pt)\n                if d > best_r:\n                    best_r = d\n                    best_pt = pt\n            y += resolution\n        x += resolution\n    if best_pt is None:\n        return None, 0.0\n    return best_pt, best_r\n\n\ndef validate_packing(centers, radii):\n    \"\"\"\n    Validate that circles don't overlap and are inside the unit square\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    n = centers.shape[0]\n\n    # Check if circles are inside the unit square with tolerance\n    tol = 1e-6\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if (x - r < -tol) or (x + r > 1 + tol) or (y - r < -tol) or (y + r > 1 + tol):\n            message = (\n                f\"Circle {i} at ({x}, {y}) with radius {r} is outside the unit square\"\n            )\n            return False, message\n\n    # Check for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if dist < radii[i] + radii[j]:\n                message = f\"Circles {i} and {j} overlap: dist={dist}, r1+r2={radii[i]+radii[j]}\"\n                return False, message\n\n    return True, \"success\"\n\n\n# DEBUG: added adaptive_bisection function for adaptive radial bisection correction\ndef adaptive_bisection(centers, radii, tol=1e-6, max_iter=20):\n    \"\"\"\n    Shrink radii by bisection until packing is valid.\n    Returns adjusted radii that satisfy non-overlap and boundary constraints.\n    \"\"\"\n    low, high = 0.0, 1.0\n    for _ in range(max_iter):\n        mid = (low + high) / 2\n        radii_mid = radii * mid\n        valid_mid, _ = validate_packing(centers, radii_mid)\n        if valid_mid:\n            low = mid\n        else:\n            high = mid\n        if (high - low) < tol:\n            break\n    radii_scaled = radii * low\n    return radii_scaled\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = construct_packing(n=28)\n    print(\"centers\", centers)\n    print(\"radii\", radii)\n    print(\"sum_radii\", sum_radii)\n\n    valid_packing, message_packing = validate_packing(centers, radii)\n    print(\"valid_packing\", valid_packing)\n    print(\"message_packing\", message_packing)\n\n    # visualize(centers, radii)\n"
}