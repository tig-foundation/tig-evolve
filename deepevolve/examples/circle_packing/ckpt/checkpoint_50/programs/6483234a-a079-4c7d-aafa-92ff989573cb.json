{
  "id": "6483234a-a079-4c7d-aafa-92ff989573cb",
  "idea": {
    "description": "Sobol-Based Initialization with Adaptive Jamming and Bisection Correction",
    "motivation": "To efficiently generate high-quality, valid circle packings for 26\u201332 circles, this approach combines low-discrepancy Sobol sampling with geometry-based power diagram partitioning computed via SciPy\u2019s ConvexHull. It incorporates a physics-inspired repulsive expansion phase with calibrated repulsive force parameters (with guidance from tools like PySwarming) to drive the configuration close to feasibility. Distinctly, it employs adaptive bisection \u2014 both per-circle and global \u2014 based on explicit stopping criteria (e.g., potential energy change thresholds, iteration limits, and MBH-like criteria) and refines via SLSQP with analytic gradients, thus ensuring that overfitting or shortcut adjustments are minimized.",
    "implementation_notes": "\u2022 Generate initial circle centers using Sobol sequences and assign preliminary radii as half the minimum inter-center distance. \n\u2022 Compute the weighted power diagram using SciPy\u2019s spatial.ConvexHull to obtain consistently oriented cells. \n\u2022 Execute a repulsive expansion phase where, for each circle, radii are incremented while applying repulsive adjustments computed via a force model (parameters A_i, B_i as in PySwarming) when overlaps or boundary violations are detected. Monitor potential energy changes and stop if the change is below a defined threshold or after reaching a maximum iteration count.\n\u2022 Apply SLSQP with analytic gradients to finely adjust centers and radii under non-overlap and containment constraints. \n\u2022 If geometric validation via Shapely fails, execute adaptive bisection: first attempting per-circle scaling based on local overlap severity, and if insufficient, apply a global scaling strategy. \n\u2022 Log and track the best valid configuration with maximal sum of radii, and record stopping criteria for reproducibility.",
    "pseudocode": "initialize centers = SobolSequence(n)\ninitialize radii = 0.5 * min(intercenter_distances)\npower_cells = compute_power_diagram(centers, radii)  // using SciPy's ConvexHull\niteration = 0\nwhile not jammed and iteration < max_iterations:\n    for each circle i:\n         radii[i] += delta\n         if (circle overlaps or exceeds boundary):\n              radii[i] -= repulsive_adjustment  // compute using repulsive_force model\n    if abs(potential_energy_change) < energy_threshold:\n         jammed = True\n    iteration += 1\nconfiguration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nif not geometric_verification(configuration):\n    radii = adaptive_bisection(radii)  // try per-circle, then global if needed\n    configuration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nreturn best_valid_configuration",
    "originality": {
      "score": 8,
      "positive": "The idea innovatively integrates Sobol-based initialization, power diagram partitioning (via SciPy\u2019s ConvexHull), adaptive jamming with physics-inspired repulsive expansion, and dual-mode adaptive bisection with clear stopping criteria, a novel blend not commonly fused in prior work.",
      "negative": "While each individual component is established, integrating them cohesively requires careful parameter calibration and robust jamming detection, which may introduce sensitivities in early prototypes."
    },
    "future_potential": {
      "score": 8,
      "positive": "The modular framework has strong potential for extensions, such as advanced interval arithmetic verification, dynamic symmetry filtering, and improved repulsive force tuning strategies, making it a versatile base for further circle packing exploration.",
      "negative": "Further empirical tuning and validation will be essential to ensure generality and robustness across different problem sizes and configurations."
    },
    "code_difficulty": {
      "score": 5,
      "positive": "The implementation leverages standard Python libraries (NumPy, SciPy, Shapely) and builds on modular components with clear geometric and optimization steps, making initial development manageable.",
      "negative": "Integrating dynamic repulsive expansion, explicit jamming detection, and dual-mode adaptive bisection with SLSQP adds complexity to parameter tuning and debugging, potentially increasing development effort."
    }
  },
  "timestamp": 1750135950.0636485,
  "parent_id": "03cb8e6e-e94e-4f60-9872-e0bc48959ce1",
  "evolution_history": [
    {
      "description": "A hybrid algorithm that integrates exact power diagram calculation with iterative refinement. The method starts by seeding circle centers, then computes an exact weighted Voronoi (power) diagram using the transformation of weighted points and 3D convex hull. It updates each circle's parameters by calculating the maximum inscribed circle within each power cell (using Shapely with precision settings) and refines the configuration using SLSQP with robust non-overlap constraints.",
      "motivation": "This approach leverages an exact geometric partitioning method to produce high-quality initial conditions, while overcoming the inaccuracy of pure numerical optimization. It ensures valid packings by combining exact power diagram computations and rigorous geometric verification, essential for advancing early-stage research on circle packing in a unit square.",
      "implementation_notes": "Implement using numpy for vectorized operations, scipy.spatial.ConvexHull for exact power diagram extraction (via transforming points to 3D), and Shapely for robust geometric checks (set_precision, buffering, and tolerance-based distance comparisons). Develop a loop that updates centers and radii iteratively and refines the configuration with SLSQP under strict non-overlap and containment constraints, referencing benchmark packings for n=26 to 32.",
      "pseudocode": "initialize centers and radii; while not converged:\n    transform centers to weighted points: (x, y, x^2+y^2-r^2);\n    compute 3D convex hull; extract lower faces to form power diagram; \n    for each power cell:\n         extract polygon vertices; \n         compute centroid and maximum inscribed circle (using Shapely with fixed precision);\n    update centers and radii; \n    refine via SLSQP with non-overlap and boundary constraints; \n    validate using Shapely (distance checks and buffers); \nreturn optimal packing",
      "originality": {
        "score": 6,
        "positive": "It creatively integrates exact power diagram computation (using a 3D convex hull method) with iterative numerical refinement, which is a novel combination for this circle packing problem.",
        "negative": "The idea builds partially on established methods; careful implementation is required to manage the complexity and numerical precision."
      },
      "future_potential": {
        "score": 8,
        "positive": "The method is scalable to other packing problems and can be further refined with advanced verification techniques, providing a rich ground for future research.",
        "negative": "Incremental improvements may be needed to ensure global optimality beyond local refinements."
      },
      "code_difficulty": {
        "score": 6,
        "positive": "The algorithm is implementable with available Python libraries and modular steps, allowing iterative improvements and integration of robust geometric operations.",
        "negative": "Implementing an exact power diagram and handling precision with Shapely increases the complexity compared to a basic SLSQP approach."
      }
    },
    {
      "description": "Multi-Start Adaptive Power Diagram with SLSQP, Analytic Gradients, and Bisection Correction",
      "motivation": "By merging low-discrepancy initialization with exact power diagram computations for preliminary radii, this strategy directly tackles non-overlap and boundary constraints through SLSQP with precise analytic gradients. Incorporating Shapely's maximum_inscribed_circle function allows robust verification and adjustment of each circle\u2019s size, while adaptive bisection addresses any constraint violations. This comprehensive integration targets both local feasibility and global exploration, ensuring that every update is guided by rigorous mathematical checks.",
      "implementation_notes": "\u2022 Use numpy to generate center candidates via a Sobol sequence.\n\u2022 Compute weighted Voronoi (power) diagrams with existing libraries such as pyhull or Power-diagram-generation to determine initial radii. \n\u2022 Use Shapely (v2.1.0) and its maximum_inscribed_circle function to compute the maximum inscribed circle for each polygonal power cell.\n\u2022 Optimize using scipy.optimize.SLSQP with analytic gradients for non-overlap (computed as -2*(x_i-x_j), -2*(y_i-y_j), 2*(r_i+r_j)) and for boundary constraints (e.g., derivatives 1 and -1 as applicable).\n\u2022 If a configuration fails the high-precision geometric validation (using Shapely), apply an adaptive bisection to adjust radii, then re-optimize.\n\u2022 Ensure that all parameters, including tolerance levels and step sizes, are sufficiently documented to facilitate reproducibility.",
      "pseudocode": "for candidate in SobolSequence:\n    centers = initialize_centers(candidate)  // e.g., via Sobol sampling\n    radii = compute_initial_radii_using_power_diagram(centers)  // leverage pyhull/Power-diagram-generation\n    // Optionally, refine each radius using Shapely's maximum_inscribed_circle on the corresponding power cell\n    candidate_config = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\n    if not validate_with_shapely(candidate_config):\n         candidate_config = apply_adaptive_bisection(candidate_config)  // adjust radii using branch-and-bound style reduction\n         candidate_config = SLSQP_optimize(candidate_config.centers, candidate_config.radii, constraints, analytic_gradients)\n    update_best_solution_if_improved(candidate_config)\nreturn best_solution",
      "originality": {
        "score": 8,
        "positive": "The idea uniquely integrates robust power diagram computation using external libraries, analytic gradients for precise SLSQP optimization, and Shapely's MIC evaluation for geometric verification. This combination of tools is not common in prior approaches and addresses key limitations identified in earlier methods.",
        "negative": "The integration relies on several external libraries and carefully tuned parameters, which may demand extensive calibration and limit immediate out-of-the-box performance."
      },
      "future_potential": {
        "score": 8,
        "positive": "Its modular framework allows for incremental enhancements, such as incorporating homotopy continuation for gradual circle inflation or integrating graph-based initialization using Delaunay triangulation. The approach lays a strong foundation for extending to more complex or higher-dimensional packing problems.",
        "negative": "Future success depends on achieving robust integration between the global initialization and local correction stages, and extensive testing may be required to ensure reliability across diverse instances."
      },
      "code_difficulty": {
        "score": 6,
        "positive": "The implementation uses well-documented libraries (numpy, scipy, Shapely, pyhull/Open3D) and a modular design that isolates each computational task, easing debugging and future enhancements.",
        "negative": "Integrating analytic gradient computation, precise geometric verification, and adaptive bisection increases the complexity of parameter tuning and debugging, which may lengthen development time."
      }
    },
    {
      "description": "Sobol-Based Initialization with Adaptive Jamming and Bisection Correction",
      "motivation": "To efficiently generate high-quality, valid circle packings for 26\u201332 circles, this approach combines low-discrepancy Sobol sampling with geometry-based power diagram partitioning computed via SciPy\u2019s ConvexHull. It incorporates a physics-inspired repulsive expansion phase with calibrated repulsive force parameters (with guidance from tools like PySwarming) to drive the configuration close to feasibility. Distinctly, it employs adaptive bisection \u2014 both per-circle and global \u2014 based on explicit stopping criteria (e.g., potential energy change thresholds, iteration limits, and MBH-like criteria) and refines via SLSQP with analytic gradients, thus ensuring that overfitting or shortcut adjustments are minimized.",
      "implementation_notes": "\u2022 Generate initial circle centers using Sobol sequences and assign preliminary radii as half the minimum inter-center distance. \n\u2022 Compute the weighted power diagram using SciPy\u2019s spatial.ConvexHull to obtain consistently oriented cells. \n\u2022 Execute a repulsive expansion phase where, for each circle, radii are incremented while applying repulsive adjustments computed via a force model (parameters A_i, B_i as in PySwarming) when overlaps or boundary violations are detected. Monitor potential energy changes and stop if the change is below a defined threshold or after reaching a maximum iteration count.\n\u2022 Apply SLSQP with analytic gradients to finely adjust centers and radii under non-overlap and containment constraints. \n\u2022 If geometric validation via Shapely fails, execute adaptive bisection: first attempting per-circle scaling based on local overlap severity, and if insufficient, apply a global scaling strategy. \n\u2022 Log and track the best valid configuration with maximal sum of radii, and record stopping criteria for reproducibility.",
      "pseudocode": "initialize centers = SobolSequence(n)\ninitialize radii = 0.5 * min(intercenter_distances)\npower_cells = compute_power_diagram(centers, radii)  // using SciPy's ConvexHull\niteration = 0\nwhile not jammed and iteration < max_iterations:\n    for each circle i:\n         radii[i] += delta\n         if (circle overlaps or exceeds boundary):\n              radii[i] -= repulsive_adjustment  // compute using repulsive_force model\n    if abs(potential_energy_change) < energy_threshold:\n         jammed = True\n    iteration += 1\nconfiguration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nif not geometric_verification(configuration):\n    radii = adaptive_bisection(radii)  // try per-circle, then global if needed\n    configuration = SLSQP_optimize(centers, radii, constraints, analytic_gradients)\nreturn best_valid_configuration",
      "originality": {
        "score": 8,
        "positive": "The idea innovatively integrates Sobol-based initialization, power diagram partitioning (via SciPy\u2019s ConvexHull), adaptive jamming with physics-inspired repulsive expansion, and dual-mode adaptive bisection with clear stopping criteria, a novel blend not commonly fused in prior work.",
        "negative": "While each individual component is established, integrating them cohesively requires careful parameter calibration and robust jamming detection, which may introduce sensitivities in early prototypes."
      },
      "future_potential": {
        "score": 8,
        "positive": "The modular framework has strong potential for extensions, such as advanced interval arithmetic verification, dynamic symmetry filtering, and improved repulsive force tuning strategies, making it a versatile base for further circle packing exploration.",
        "negative": "Further empirical tuning and validation will be essential to ensure generality and robustness across different problem sizes and configurations."
      },
      "code_difficulty": {
        "score": 5,
        "positive": "The implementation leverages standard Python libraries (NumPy, SciPy, Shapely) and builds on modular components with clear geometric and optimization steps, making initial development manageable.",
        "negative": "Integrating dynamic repulsive expansion, explicit jamming detection, and dual-mode adaptive bisection with SLSQP adds complexity to parameter tuning and debugging, potentially increasing development effort."
      }
    }
  ],
  "iteration_found": 15,
  "metrics": {
    "combined_score": 0.7817614693789372,
    "runtime_seconds": 206.58,
    "sum_radii_for_n_26": 0.0,
    "ratio_to_sota_for_n_26": 0.0,
    "validity_for_n_26": 0.0,
    "message_for_n_26": "Circles 0 and 4 overlap: dist=0.15348042767632397, r1+r2=0.15348042767632764",
    "sum_radii_for_n_27": 2.668571056488592,
    "ratio_to_sota_for_n_27": 0.9938812128449133,
    "validity_for_n_27": 1.0,
    "sum_radii_for_n_28": 0.0,
    "ratio_to_sota_for_n_28": 0.0,
    "validity_for_n_28": 0.0,
    "message_for_n_28": "Circles 0 and 4 overlap: dist=0.15348042767632397, r1+r2=0.15348042767632764",
    "sum_radii_for_n_29": 0.0,
    "ratio_to_sota_for_n_29": 0.0,
    "validity_for_n_29": 0.0,
    "message_for_n_29": "Circles 0 and 4 overlap: dist=0.15348042767632397, r1+r2=0.15348042767632764",
    "sum_radii_for_n_30": 2.803759229163969,
    "ratio_to_sota_for_n_30": 0.9865444156101227,
    "validity_for_n_30": 1.0,
    "sum_radii_for_n_31": 0.0,
    "ratio_to_sota_for_n_31": 0.0,
    "validity_for_n_31": 0.0,
    "message_for_n_31": "Circles 0 and 4 overlap: dist=0.15348042767632397, r1+r2=0.15348042767632764",
    "sum_radii_for_n_32": 0.0,
    "ratio_to_sota_for_n_32": 0.0,
    "validity_for_n_32": 0.0,
    "message_for_n_32": "Circles 0 and 4 overlap: dist=0.15348042767632397, r1+r2=0.15348042767632764",
    "overall_validity": 0.0
  },
  "metadata": {
    "parent_metrics": {
      "combined_score": 0.36885306726088835,
      "runtime_seconds": 210.8,
      "sum_radii_for_n_26": 2.5819714708262183,
      "ratio_to_sota_for_n_26": 0.9795545934793648,
      "validity_for_n_26": 1.0,
      "sum_radii_for_n_27": 0.0,
      "ratio_to_sota_for_n_27": 0.0,
      "validity_for_n_27": 0.0,
      "message_for_n_27": "Circles 0 and 9 overlap: dist=0.16739871430451253, r1+r2=0.16739871430451786",
      "sum_radii_for_n_28": 0.0,
      "ratio_to_sota_for_n_28": 0.0,
      "validity_for_n_28": 1.0,
      "sum_radii_for_n_29": 0.0,
      "ratio_to_sota_for_n_29": 0.0,
      "validity_for_n_29": 0.0,
      "message_for_n_29": "Circles 0 and 9 overlap: dist=0.16739871430451253, r1+r2=0.16739871430451786",
      "sum_radii_for_n_30": 0.0,
      "ratio_to_sota_for_n_30": 0.0,
      "validity_for_n_30": 0.0,
      "message_for_n_30": "Circles 0 and 9 overlap: dist=0.16739871430451253, r1+r2=0.16739871430451786",
      "sum_radii_for_n_31": 0.0,
      "ratio_to_sota_for_n_31": 0.0,
      "validity_for_n_31": 0.0,
      "message_for_n_31": "Circles 0 and 9 overlap: dist=0.16739871430451253, r1+r2=0.16739871430451786",
      "sum_radii_for_n_32": 0.0,
      "ratio_to_sota_for_n_32": 0.0,
      "validity_for_n_32": 0.0,
      "message_for_n_32": "Circles 0 and 9 overlap: dist=0.16739871430451253, r1+r2=0.16739871430451786",
      "overall_validity": 0.0
    },
    "island": 2
  },
  "language": "python",
  "report": "This report synthesizes insights from our starting idea and related works to advance an algorithm for maximizing the sum of circle radii in a unit square (for 26\u201332 circles). Our key insights include: (1) Using power diagrams computed via SciPy\u2019s spatial.ConvexHull and low-discrepancy Sobol sampling reliably partitions the space, yielding high-quality initial candidates; (2) Analytic gradient-based SLSQP optimization, enhanced through adaptive bisection (with both per-circle and global strategies) and clear stopping criteria, can refine candidates while strictly enforcing non-overlap and containment constraints; (3) Physics-inspired repulsive expansion with explicit jamming detection\u2014monitoring potential energy changes and density deviations\u2014drives configurations toward near-feasible states; (4) Robust geometric validation via Shapely (with exact MIC and clipping) ensures high precision; (5) Symmetry-breaking during initialization limits redundant searches. \n\nThese insights naturally group into three research directions: robust initialization with weighted Voronoi (power) diagrams and Sobol sequences; adaptive correction using per-circle/global bisection and physics-based jamming detection; and hybrid optimization combining global exploration (via physics-inspired repulsion) with local refinement by SLSQP. Our framework begins with candidate generation using uniform Sobol sampling, followed by power diagram computation (leveraging SciPy\u2019s convex hull routines), a repulsive expansion phase that uses adjustable force models (with references to PySwarming parameters), and finally SLSQP refinement with adaptive bisection triggered by rigorous Shapely-based validation. This integrated structure mitigates risks of overfitting and shortcut learning by explicitly monitoring stopping criteria and ensuring reproducibility.\n",
  "code": "# === deepevolve_interface.py ===\nfrom main import construct_packing, validate_packing\nfrom time import time\nimport numpy as np\nimport traceback\nimport signal\nfrom contextlib import contextmanager\n\n\n@contextmanager\ndef timeout(duration):\n    \"\"\"Context manager for timing out function calls\"\"\"\n\n    def timeout_handler(signum, frame):\n        raise TimeoutError(f\"Function call timed out after {duration} seconds\")\n\n    # Set the signal handler\n    old_handler = signal.signal(signal.SIGALRM, timeout_handler)\n    signal.alarm(duration)\n\n    try:\n        yield\n    finally:\n        # Restore the old signal handler\n        signal.signal(signal.SIGALRM, old_handler)\n        signal.alarm(0)\n\n\ndef deepevolve_interface():\n    try:\n        start_time = time()\n\n        # SOTA values for comparison\n        sota_values = {\n            26: 2.6358627564136983,\n            27: 2.685,\n            28: 2.737,\n            29: 2.790,\n            30: 2.842,\n            31: 2.889,\n            32: 2.937944526205518,\n        }\n\n        all_results = {}\n        all_sum_radii = []\n\n        # Run for n from 26 to 32\n        for n in range(26, 33):\n            # Apply 1-minute timeout to construct_packing\n            try:\n                with timeout(60):\n                    centers, radii, sum_radii = construct_packing(n=n)\n\n                if not isinstance(centers, np.ndarray):\n                    centers = np.array(centers)\n                if not isinstance(radii, np.ndarray):\n                    radii = np.array(radii)\n\n                # Validate solution\n                valid_packing, message_packing = validate_packing(centers, radii)\n\n                if not valid_packing:\n                    print(f\"Invalid packing for n={n}: {message_packing}\")\n\n            except TimeoutError:\n                print(f\"Timeout occurred for n={n}, setting sum_radii to 0\")\n                centers = np.array([])\n                radii = np.array([])\n                sum_radii = 0.0\n                valid_packing = False\n                message_packing = f\"60s Timeout occurred for n={n}\"\n\n            # Store results\n            all_results[n] = {\n                \"sum_radii\": sum_radii if valid_packing else 0.0,\n                \"valid\": valid_packing,\n                \"message\": message_packing,\n            }\n            all_sum_radii.append(sum_radii if valid_packing else 0.0)\n\n        # Calculate runtime in seconds\n        runtime = time() - start_time\n        runtime = round(runtime, 2)\n\n        combined_score = np.mean(all_sum_radii)\n\n        metrics = {\n            \"combined_score\": combined_score,\n            \"runtime_seconds\": runtime,\n        }\n\n        # Add individual sum_radii and ratios to SOTA for each n\n        for n in range(26, 33):\n            result = all_results[n]\n            sum_radii = result[\"sum_radii\"]\n            valid = result[\"valid\"]\n\n            # Add sum_radii for this n\n            metrics[f\"sum_radii_for_n_{n}\"] = sum_radii\n\n            # Calculate ratio to SOTA\n            if n in sota_values and valid:\n                sota_value = sota_values[n]\n                ratio_to_sota = sum_radii / sota_value\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = ratio_to_sota\n            else:\n                metrics[f\"ratio_to_sota_for_n_{n}\"] = 0.0\n\n            # Add validity for this n\n            metrics[f\"validity_for_n_{n}\"] = 1.0 if valid else 0.0\n            if not valid:\n                metrics[f\"message_for_n_{n}\"] = message_packing\n\n        overall_validity = all(all_results[n][\"valid\"] for n in range(26, 33))\n        metrics[\"overall_validity\"] = 1.0 if overall_validity else 0.0\n\n        return True, metrics\n\n    except Exception as e:\n        # Capture full traceback information\n        error_traceback = traceback.format_exc()\n        error_info = f\"\"\"\n            Error type: {type(e).__name__}\n            Error message: {str(e)}\n            Traceback: {error_traceback}\n        \"\"\"\n        return False, error_info\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    # plt.savefig('circle_packing.png')\n\n\nif __name__ == \"__main__\":\n    status, metrics = deepevolve_interface()\n    print(f\"Status: {status}\")\n    print(f\"Metrics: {metrics}\")\n    # AlphaEvolve improved this to 2.635\n\n\n# === main.py ===\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nfrom time import time\nimport traceback\nfrom scipy.optimize import minimize\n\n\n# DEBUG: added adaptive_jamming_phase to perform repulsive expansion phase (stub)\ndef adaptive_jamming_phase(x, n, max_iter=10, shrink_factor=0.95):\n    \"\"\"\n    Adaptive jamming phase: iteratively shrink radii until packing is valid.\n    \"\"\"\n    # x contains [centers.flatten(), radii]\n    centers = x[: 2 * n].reshape(n, 2)\n    radii = x[2 * n :].copy()\n    for _ in range(max_iter):\n        valid, _ = validate_packing(centers, radii)\n        if valid:\n            break\n        # shrink radii to alleviate overlaps/boundary violations\n        radii = radii * shrink_factor\n    # return updated x vector\n    return np.hstack((centers.flatten(), radii))\n\n\ndef construct_packing(n=26):\n    \"\"\"\n    Compute circle packing for n circles in the unit square using multiple SLSQP restarts.\n    Returns:\n        centers: array of shape (n, 2)\n        radii: array of shape (n,)\n        sum_radii: float\n    \"\"\"\n    # Prebuild bounds and constraints\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    constraints = []\n\n    # Non-overlap constraints with analytic gradients\n    def non_overlap_gradient(x, i, j):\n        xi, yi = x[2 * i], x[2 * i + 1]\n        xj, yj = x[2 * j], x[2 * j + 1]\n        diff = np.array([xi - xj, yi - yj])\n        d = np.hypot(diff[0], diff[1]) + 1e-10\n        grad = np.zeros_like(x)\n        grad[2 * i] = diff[0] / d\n        grad[2 * i + 1] = diff[1] / d\n        grad[2 * j] = -diff[0] / d\n        grad[2 * j + 1] = -diff[1] / d\n        grad[2 * n + i] = -1\n        grad[2 * n + j] = -1\n        return grad\n\n    for i in range(n):\n        for j in range(i + 1, n):\n\n            def overlap(x, i=i, j=j):\n                xi, yi = x[2 * i], x[2 * i + 1]\n                xj, yj = x[2 * j], x[2 * j + 1]\n                ri = x[2 * n + i]\n                rj = x[2 * n + j]\n                dist = np.hypot(xi - xj, yi - yj)\n                return dist - (ri + rj)\n\n            def overlap_jac(x, i=i, j=j):\n                return non_overlap_gradient(x, i, j)\n\n            constraints.append({\"type\": \"ineq\", \"fun\": overlap, \"jac\": overlap_jac})\n\n    # Boundary constraints with analytic gradients\n    def jac_left(x, i):\n        grad = np.zeros_like(x)\n        grad[2 * i] = 1\n        grad[2 * n + i] = -1\n        return grad\n\n    def jac_right(x, i):\n        grad = np.zeros_like(x)\n        grad[2 * i] = -1\n        grad[2 * n + i] = -1\n        return grad\n\n    def jac_bottom(x, i):\n        grad = np.zeros_like(x)\n        grad[2 * i + 1] = 1\n        grad[2 * n + i] = -1\n        return grad\n\n    def jac_top(x, i):\n        grad = np.zeros_like(x)\n        grad[2 * i + 1] = -1\n        grad[2 * n + i] = -1\n        return grad\n\n    for i in range(n):\n\n        def left(x, i=i):\n            return x[2 * i] - x[2 * n + i]\n\n        def right(x, i=i):\n            return 1 - (x[2 * i] + x[2 * n + i])\n\n        def bottom(x, i=i):\n            return x[2 * i + 1] - x[2 * n + i]\n\n        def top(x, i=i):\n            return 1 - (x[2 * i + 1] + x[2 * n + i])\n\n        constraints.extend(\n            [\n                {\"type\": \"ineq\", \"fun\": left, \"jac\": lambda x, i=i: jac_left(x, i)},\n                {\"type\": \"ineq\", \"fun\": right, \"jac\": lambda x, i=i: jac_right(x, i)},\n                {\"type\": \"ineq\", \"fun\": bottom, \"jac\": lambda x, i=i: jac_bottom(x, i)},\n                {\"type\": \"ineq\", \"fun\": top, \"jac\": lambda x, i=i: jac_top(x, i)},\n            ]\n        )\n\n    best_sum = -np.inf\n    best_x = None\n\n    ### >>> DEEPEVOLVE-BLOCK-START: Sobol-Based Initialization with Adaptive Jamming\n    from scipy.stats import qmc\n\n    sampler = qmc.Sobol(d=2, scramble=True, seed=42)\n    centers0 = sampler.random(n)\n    centers0 = 0.1 + 0.8 * centers0\n    if n > 1:\n        from scipy.spatial.distance import pdist\n\n        min_dist = np.min(pdist(centers0))\n    else:\n        min_dist = 0.1\n    radii0 = np.full(n, 0.5 * min_dist)\n    x0 = np.hstack((centers0.flatten(), radii0))\n    x0 = adaptive_jamming_phase(x0, n)\n    ### <<< DEEPEVOLVE-BLOCK-END\n\n    def objective(x):\n        return -np.sum(x[2 * n :])\n\n    ### >>> DEEPEVOLVE-BLOCK-START: Remove Duplicate definition of objective_jac\n    def objective_jac(x):\n        grad = np.zeros_like(x)\n        grad[2 * n :] = -1\n        return grad\n\n    ### <<< DEEPEVOLVE-BLOCK-END\n\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-6},\n    )\n\n    if result.success:\n        radii = result.x[2 * n :]\n        total = np.sum(radii)\n        if total > best_sum:\n            best_sum = total\n            best_x = result.x.copy()\n\n    if best_x is None:\n        # DEBUG: no valid SLSQP result, fallback to last optimization output to proceed with refinement\n        best_x = result.x.copy()\n        best_sum = np.sum(best_x[2 * n :])\n        print(\n            f\"Warning: No valid candidate found for circle packing for n={n}, proceeding with fallback solution.\"\n        )\n\n    centers = best_x[: 2 * n].reshape(n, 2)\n    radii = best_x[2 * n :]\n\n    # Iterative refinement using power diagram and maximum inscribed circles\n    for _ in range(10):\n        cells = compute_power_cells(centers, radii)\n        new_centers = []\n        new_radii = []\n        for i, cell in enumerate(cells):\n            if cell.is_empty:\n                new_centers.append(centers[i])\n                new_radii.append(radii[i] * 0.9)\n            else:\n                point, r_val = find_max_inscribed_circle(cell, resolution=0.002)\n                if point is None:\n                    new_centers.append(centers[i])\n                    new_radii.append(radii[i])\n                else:\n                    new_centers.append([point.x, point.y])\n                    new_radii.append(min(r_val, radii[i] + 0.001))\n        new_centers = np.array(new_centers)\n        new_radii = np.array(new_radii)\n        if (\n            np.linalg.norm(new_centers - centers) < 1e-4\n            and np.linalg.norm(new_radii - radii) < 1e-4\n        ):\n            centers, radii = new_centers, new_radii\n            break\n        centers, radii = new_centers, new_radii\n\n    # Final refinement with SLSQP to enforce non-overlap and boundary constraints\n    x0 = np.hstack((centers.flatten(), radii))\n    result = minimize(\n        objective,\n        x0,\n        method=\"SLSQP\",\n        jac=objective_jac,\n        bounds=bounds,\n        constraints=constraints,\n        options={\"maxiter\": 1000, \"ftol\": 1e-8},\n    )\n    if result.success:\n        radii = result.x[2 * n :]\n        centers = result.x[: 2 * n].reshape(n, 2)\n        best_sum = np.sum(radii)\n    # If the final solution is invalid, apply adaptive bisection and re-optimize\n    valid, msg = validate_packing(centers, radii)\n    if not valid:\n        radii = adaptive_bisection(centers, radii)\n        x0 = np.hstack((centers.flatten(), radii))\n        result = minimize(\n            objective,\n            x0,\n            method=\"SLSQP\",\n            jac=objective_jac,\n            bounds=bounds,\n            constraints=constraints,\n            options={\"maxiter\": 1000, \"ftol\": 1e-8},\n        )\n        if result.success:\n            radii = result.x[2 * n :]\n            centers = result.x[: 2 * n].reshape(n, 2)\n            best_sum = np.sum(radii)\n\n    return centers, radii, best_sum\n\n\n# DEBUG: added missing compute_power_cells and find_max_inscribed_circle implementations\n### <<< DEEPEVOLVE-BLOCK-END\nfrom shapely.geometry import Polygon, Point, LineString\nfrom shapely.ops import split\n\n\ndef compute_power_cells(centers, radii):\n    \"\"\"\n    Compute power cells (weighted Voronoi) for given centers and radii inside the unit square.\n    Returns a list of shapely Polygon objects representing each cell.\n    \"\"\"\n    # build a large bounding box for half\u2010space intersections\n    M = 10.0\n    bb = Polygon([(-M, -M), (M, -M), (M, M), (-M, M)])\n    # start from the unit square\n    domain = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n    cells = []\n    n = len(centers)\n    for i in range(n):\n        poly = domain\n        cx_i, cy_i = centers[i]\n        weight_i = cx_i * cx_i + cy_i * cy_i - radii[i] * radii[i]\n        for j in range(n):\n            if j == i:\n                continue\n            cx_j, cy_j = centers[j]\n            weight_j = cx_j * cx_j + cy_j * cy_j - radii[j] * radii[j]\n            # half\u2010space: 2*(c_j - c_i)\u22c5x <= weight_j - weight_i\n            a = 2 * (cx_j - cx_i)\n            b = 2 * (cy_j - cy_i)\n            c = weight_j - weight_i\n            # build splitting line across the big box\n            if abs(b) > abs(a) and b != 0:\n                p1 = Point(-M, (c - a * (-M)) / b)\n                p2 = Point(M, (c - a * (M)) / b)\n            else:\n                # vertical line (avoid division by zero)\n                if a == 0:\n                    poly = Polygon()\n                    break\n                p1 = Point(c / a, -M)\n                p2 = Point(c / a, M)\n            line = LineString([p1, p2])\n            # split the bounding box into two half\u2010spaces\n            # DEBUG: shapely.ops.split returns a GeometryCollection, which is not directly iterable; iterate over pieces.geoms\n            pieces = split(bb, line)\n            halfspace = None\n            for piece in pieces.geoms:\n                test_pt = piece.representative_point()\n                if a * test_pt.x + b * test_pt.y <= c:\n                    halfspace = piece\n                    break\n            if halfspace is None:\n                poly = Polygon()\n                break\n            poly = poly.intersection(halfspace)\n            if poly.is_empty:\n                break\n        cells.append(poly)\n    return cells\n\n\ndef find_max_inscribed_circle(polygon, resolution=0.002):\n    \"\"\"\n    Approximate the maximum inscribed circle in a polygon by grid sampling.\n    Returns (Point center, radius) or (None, 0) if the polygon is empty.\n    \"\"\"\n    if polygon.is_empty:\n        return None, 0.0\n    minx, miny, maxx, maxy = polygon.bounds\n    best_pt = None\n    best_r = 0.0\n    x = minx\n    while x <= maxx:\n        y = miny\n        while y <= maxy:\n            pt = Point(x, y)\n            if polygon.contains(pt):\n                # distance to the boundary\n                d = polygon.boundary.distance(pt)\n                if d > best_r:\n                    best_r = d\n                    best_pt = pt\n            y += resolution\n        x += resolution\n    if best_pt is None:\n        return None, 0.0\n    return best_pt, best_r\n\n\n### >>> DEEPEVOLVE-BLOCK-START: Adaptive Bisection for Radii Adjustment\ndef adaptive_bisection(centers, radii, tol=1e-4, max_iter=10):\n    \"\"\"\n    Adaptively scale down the radii until the packing becomes valid.\n    If after max_iter valid configuration is not reached, a warning is issued.\n    \"\"\"\n    for iteration in range(max_iter):\n        valid, msg = validate_packing(centers, radii)\n        if valid:\n            return radii\n        radii = radii * 0.95\n    print(\n        \"Warning: adaptive_bisection did not achieve a valid configuration after\",\n        max_iter,\n        \"iterations. Returning last radii.\",\n    )\n    return radii\n\n\n### <<< DEEPEVOLVE-BLOCK-END\n\n\ndef validate_packing(centers, radii):\n    \"\"\"\n    Validate that circles don't overlap and are inside the unit square\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    n = centers.shape[0]\n\n    # Check if circles are inside the unit square with tolerance\n    tol = 1e-6\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if (x - r < -tol) or (x + r > 1 + tol) or (y - r < -tol) or (y + r > 1 + tol):\n            message = (\n                f\"Circle {i} at ({x}, {y}) with radius {r} is outside the unit square\"\n            )\n            return False, message\n\n    # Check for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if dist < radii[i] + radii[j]:\n                message = f\"Circles {i} and {j} overlap: dist={dist}, r1+r2={radii[i]+radii[j]}\"\n                return False, message\n\n    return True, \"success\"\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n    plt.savefig(\"circle_packing.png\")\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = construct_packing(n=28)\n    print(\"centers\", centers)\n    print(\"radii\", radii)\n    print(\"sum_radii\", sum_radii)\n\n    valid_packing, message_packing = validate_packing(centers, radii)\n    print(\"valid_packing\", valid_packing)\n    print(\"message_packing\", message_packing)\n\n    # visualize(centers, radii)\n"
}