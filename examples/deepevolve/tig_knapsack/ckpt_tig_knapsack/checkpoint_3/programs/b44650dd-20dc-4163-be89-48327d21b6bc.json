{
  "id": "b44650dd-20dc-4163-be89-48327d21b6bc",
  "idea": {
    "description": "A Memetic Algorithm with Local Search, integrating local optimization within genetic algorithms to refine solution quality while considering item interactions.",
    "motivation": "Integrates both global exploration and local refinement strategies to avoid local optima and enhance solution quality. Provides mechanisms to maintain population diversity, essential for complex combinatorial problems like the QKP.",
    "implementation_notes": "Focus on maintaining population diversity through strategies like the Dynamic Island Model (DIM-SP) or self-adaptive mechanisms. Efficiently evaluate item interactions during genetic operations. Continuous iterations over hyperparameters will ensure optimization through adjustments based on performance metrics.",
    "pseudocode": "fn memetic_algorithm(weights, values, interaction_values, max_weight) {  \n    let population = initialize_population();  \n    while !converged {  \n        eval_population(&population, &interaction_values, &weights, &values);  \n        let parents = select_parents(&population);  \n        let offspring = crossover(parents);  \n        apply_mutation(&offspring);\n        let optimized_offspring = local_search(offspring, weights, interaction_values);\n        population = select_next_population(population, optimized_offspring);\n    }  \n    return get_best_solution(population);  \n}",
    "originality": {
      "score": 9,
      "positive": "Uniquely integrates local search refinements into GA to improve QKP solution quality and convergence speed. Combines advanced strategies for population maintenance and interaction assessment, ensuring comprehensive exploration of the solution space.",
      "negative": "While unique, numerous studies exist exploring similar concepts without being tailored to QKP specifics."
    },
    "future_potential": {
      "score": 9,
      "positive": "Potential to spark further research, especially in hyperparameter tuning and local search strategies. Promotes deeper investigations into interaction-based optimizations.",
      "negative": "Performance reliant on effective parameter tuning could complicate initial implementation."
    },
    "code_difficulty": {
      "score": 7,
      "positive": "Conceptually clear to implement in stages with clear steps and modular components for local optimization.",
      "negative": "Effective population management coupled with local optimizations will require careful coding."
    }
  },
  "timestamp": 1765883867.7087796,
  "parent_id": "root",
  "evolution_history": [
    {
      "description": "A Memetic Algorithm with Local Search, integrating local optimization within genetic algorithms to refine solution quality while considering item interactions.",
      "motivation": "Integrates both global exploration and local refinement strategies to avoid local optima and enhance solution quality. Provides mechanisms to maintain population diversity, essential for complex combinatorial problems like the QKP.",
      "implementation_notes": "Focus on maintaining population diversity through strategies like the Dynamic Island Model (DIM-SP) or self-adaptive mechanisms. Efficiently evaluate item interactions during genetic operations. Continuous iterations over hyperparameters will ensure optimization through adjustments based on performance metrics.",
      "pseudocode": "fn memetic_algorithm(weights, values, interaction_values, max_weight) {  \n    let population = initialize_population();  \n    while !converged {  \n        eval_population(&population, &interaction_values, &weights, &values);  \n        let parents = select_parents(&population);  \n        let offspring = crossover(parents);  \n        apply_mutation(&offspring);\n        let optimized_offspring = local_search(offspring, weights, interaction_values);\n        population = select_next_population(population, optimized_offspring);\n    }  \n    return get_best_solution(population);  \n}",
      "originality": {
        "score": 9,
        "positive": "Uniquely integrates local search refinements into GA to improve QKP solution quality and convergence speed. Combines advanced strategies for population maintenance and interaction assessment, ensuring comprehensive exploration of the solution space.",
        "negative": "While unique, numerous studies exist exploring similar concepts without being tailored to QKP specifics."
      },
      "future_potential": {
        "score": 9,
        "positive": "Potential to spark further research, especially in hyperparameter tuning and local search strategies. Promotes deeper investigations into interaction-based optimizations.",
        "negative": "Performance reliant on effective parameter tuning could complicate initial implementation."
      },
      "code_difficulty": {
        "score": 7,
        "positive": "Conceptually clear to implement in stages with clear steps and modular components for local optimization.",
        "negative": "Effective population management coupled with local optimizations will require careful coding."
      }
    }
  ],
  "iteration_found": 3,
  "metrics": {
    "combined_score": 0.0
  },
  "metadata": {
    "parent_metrics": {
      "combined_score": -16335.0,
      "quality": -16335.0,
      "time_seconds": 0.000786049,
      "memory_kb": 3712
    },
    "island": 0
  },
  "language": "rust",
  "report": "## Research Report on Evolving Rust Algorithm for Quadratic Knapsack Problem\n\n### 1. Extract Insights\n\n**Starting Research Idea Insights:**  \n1. **Greedy Value/Weight Seed Approach:** This heuristic utilizes the ratio of value to weight to select items and adds a positive interaction bonus. It effectively identifies high-value items while considering item interactions, which is critical in a problem where synergy impacts total value significantly.  \n2. **Iterative Improvement via DeepEvolve Techniques:** The initial approach sets the stage for further refinements through iterative processes, allowing for the exploration of more complex relationships in item interactions, potentially leading to better optimization results.  \n3. **Focus on Efficiency and Scalability:** The approach implicitly values the need for solutions that scale well with the problem size, which is paramount given the exponential nature of QKP complexity.  \n\n**Related Works Insights:**  \n1. **Genetic Algorithm with Interaction Scoring:** This method enhances solution quality by evaluating item interactions alongside individual contributions, suggesting that leveraging synergy can improve total value\u2014a core aspect of the problem.  \n2. **Hybrid Memetic Algorithms:** Combining local search strategies with genetic algorithms can refine solutions and avoid local optima, proving valuable in exploring the vast solution space of QKP.  \n3. **Breakpoints Algorithm:** Utilizing a fast greedy heuristic to identify optimal solutions within specified budgets reveals an important avenue of using heuristics effectively to address QKP's computational challenges.  \n\n### 2. Organize Research Directions\n\n1. **Optimization Techniques:**  \n   - Greedy methods with adjustments for interactions.  \n   - Genetic algorithms incorporating local search to refine solutions.\n\n2. **Hybrid Approaches:**  \n   - Integrating memetic algorithms with local search enhancements.  \n   - Evaluating the use of interaction characteristics between items as essential to solution efficiency.  \n\n3. **Decomposition Methods:**  \n   - Employing techniques such as the Breakpoints Algorithm to handle large instances effectively.\n\n### 3. Structured Framework\n\n| Methodology                | Key Features                           | Notable References                             |\n|---------------------------|----------------------------------------|------------------------------------------------|\n| Greedy Algorithms          | Value/Weight ratio, Synergy Bonuses   | Initial Research Idea                           |\n| Genetic Algorithms         | Item synergies, Population dynamics    | Hybrid Memetic Algorithm, Genetic Algorithm with Interaction Scoring |\n| Memetic Algorithms         | Hybridization with local search       | Studies on multi-factorial optimization         |\n| Breakpoints Algorithm      | Fast heuristic, Scalability and Efficiency | QKBP applications on large instances              |\n\n### 4. Generate and Evaluate Ideas\n\n1. **Modified Greedy Approach**  \n   - **Pseudocode:**  \n     ```rust  \n     fn modified_greedy(weights, values, interaction_values, max_weight){  \n         let mut selected = Vec::new();  \n         let mut total_weight = 0;  \n         let mut value_and_interaction = Vec::new();  \n         for i in 0..weights.len() {  \n             // Calculate adjusted value considering interactions   \n             let adjusted_value = values[i]; // + interaction_score_logic;  \n             value_and_interaction.push((adjusted_value, weights[i], i));  \n         }  \n         value_and_interaction.sort_by(|a, b| b.0.cmp(&a.0));  \n         for (_, weight, index) in value_and_interaction {  \n             if total_weight + weight <= max_weight {  \n                 selected.push(index);  \n                 total_weight += weight;  \n             }  \n         }  \n         return selected;  \n     } \n     ```  \n   - Originality: 8, Future Potential: 7, Code Difficulty: 4 \n\n2. **Genetic Algorithm with Pairwise Interactions**  \n   - **Pseudocode:**  \n     ```rust  \n     fn genetic_algorithm(weights, values, interaction_values, max_weight){  \n         // Initialize population  \n         let population = initialize_population();  \n         // Evaluate fitness considering interactions  \n         // Maintain diversity via strategies such as tournament selection or DIM-SP  \n         for generation in 0..MAX_GENERATIONS {  \n             let scores = eval_population(population, interaction_values, weights, values);\n             let parents = select_parents(population, scores);\n             let offspring = crossover(parents);\n             apply_mutation(offspring);\n             population = select_next_population(population, offspring);\n         }  \n         return best_solution(population);  \n     } \n     ```  \n   - Originality: 8, Future Potential: 9, Code Difficulty: 6 \n\n3. **Memetic Algorithm with Local Search**  \n   - **Pseudocode:**  \n     ```rust  \n     fn memetic_algorithm(weights, values, interaction_values, max_weight) {  \n         let population = initialize_population();  \n         while !converged {  \n             eval_population(&population, &interaction_values, &weights, &values);  \n             let parents = select_parents(&population);  \n             let offspring = crossover(parents);  \n             apply_mutation(&offspring);\n             let optimized_offspring = local_search(offspring, &weights, &interaction_values);\n             population = select_next_population(population, optimized_offspring);\n         }  \n         return get_best_solution(population);  \n     }  \n     ```  \n   - Originality: 9, Future Potential: 9, Code Difficulty: 7 \n\n### Selected Idea: Memetic Algorithm with Local Search\n\n- **Rationale**: The integration of local search enhances the algorithm's ability to refine solutions in a manner that is deeply rooted in evolutionary principles, allowing for both exploration and exploitation of the solution space effectively. Furthermore, the approach promises significant improvements in solution quality over the greedy methods previously explored. Additionally, it leverages strategies to maintain population diversity to prevent premature convergence. \n\n- **Detailed Pseudocode**:\n   ```rust  \n   fn memetic_algorithm(weights, values, interaction_values, max_weight) {  \n       let population = initialize_population();  \n       while !converged {  \n           eval_population(&population, &interaction_values, &weights, &values);  \n           let parents = select_parents(&population);  \n           let offspring = crossover(parents);  \n           apply_mutation(&offspring);\n           let optimized_offspring = local_search(offspring, weights, interaction_values);\n           population = select_next_population(population, optimized_offspring);\n       }  \n       return get_best_solution(population);  \n   }  \n   ```  \n- **Implementation Notes**: Implementation should focus on maintaining diversity within the population and efficiently handling interaction evaluations. Consider incorporating dynamic island models or self-adaptive mechanisms for enhanced population management. Testing with various parameters, including crossover rates, mutation rates, and population sizes, will be crucial to tune performance effectively based on the given hyperparameters and instance characteristics. Refer to documented strategies for hybrid GAs and local optimizations to inform implementation choices. \n\n### Conclusion\nThe proposed Memetic Algorithm with Local Search presents a novel and robust approach to solving the Quadratic Knapsack Problem, leveraging insights from hybrid evolutionary methods while incorporating interaction dynamics, demonstrating significant promise for future research and practical applications with an overall focus on optimizing both solution quality and computational efficiency.",
  "code": "# === deepevolve_interface.py ===\nimport json\nimport math\nimport os\nimport shutil\nimport subprocess\nimport traceback\nfrom pathlib import Path\n\n\ndef detect_repo_root(marker: str = \"tig.py\") -> Path:\n    \"\"\"Walk up from this file until we find the repo marker (tig.py).\"\"\"\n    for parent in Path(__file__).resolve().parents:\n        candidate = parent if (parent / marker).exists() else None\n        if candidate:\n            return candidate\n    raise FileNotFoundError(\n        f\"Could not locate repository root containing {marker}. \"\n        \"Set TIG_REPO_ROOT to override.\"\n    )\n\n\ndef resolve_repo_root() -> Path:\n    \"\"\"Resolve the TIG repo root via env override or automatic detection.\"\"\"\n    env_path = os.getenv(\"TIG_REPO_ROOT\")\n    if env_path:\n        return Path(env_path).expanduser().resolve()\n    return detect_repo_root()\n\n\n# Absolute path to the TIG repo (auto-detected unless TIG_REPO_ROOT overrides)\nREPO_ROOT = resolve_repo_root()\nALGO_RUNNER = REPO_ROOT / \"algo-runner\"\n\n# Track to evaluate; override with TIG_TRACK_ID env if needed\nTRACK_ID = os.getenv(\"TIG_TRACK_ID\", \"n_items=500,density=5\")\n\n# Quick evaluation defaults\nNUM_TESTS = int(os.getenv(\"TIG_NUM_TESTS\", \"10\"))\nTIMEOUT = int(os.getenv(\"TIG_TIMEOUT\", \"60\"))\nQUALITY_PRECISION = 1_000_000  # Matches algo-runner/src/lib.rs\nMAX_BTB = 0.001\n\n\ndef performance_scale(x: float, max_btb: float) -> float:\n    \"\"\"Smoothly scale performance based on better-than-baseline metric.\"\"\"\n    if max_btb <= 0:\n        return 0.0\n\n    numerator = math.exp(3000.0 * x) - 1.0\n    denominator = math.exp(3000.0 * max_btb) - 1.0\n\n    if denominator == 0.0:\n        return 0.0\n\n    return max(0.0, min(numerator / denominator, 1.0))\n\n\ndef run_cmd(cmd, cwd):\n    \"\"\"Run a command and return (ok, stdout, stderr).\"\"\"\n    res = subprocess.run(cmd, cwd=cwd, text=True, capture_output=True)\n    return res.returncode == 0, res.stdout, res.stderr\n\n\ndef parse_metrics(stdout: str):\n    \"\"\"\n    Parse tig.py test_algorithm output lines like:\n    Seed: 0, Quality: <q>, Time: <t>, Memory: <m>KB\n    \"\"\"\n    quality = None\n    time_s = None\n    mem_kb = None\n    for line in stdout.splitlines():\n        if \"Quality:\" in line:\n            parts = line.split(\",\")\n            for part in parts:\n                if \"Quality:\" in part:\n                    try:\n                        quality = float(part.split(\":\")[1].strip())\n                    except Exception:\n                        quality = None\n                if \"Time:\" in part:\n                    try:\n                        time_s = float(part.split(\":\")[1].strip())\n                    except Exception:\n                        time_s = None\n                if \"Memory:\" in part:\n                    try:\n                        mem_kb = int(\n                            part.split(\":\")[1]\n                            .strip()\n                            .replace(\"KB\", \"\")\n                            .strip()\n                        )\n                    except Exception:\n                        mem_kb = None\n    return quality, time_s, mem_kb\n\n\ndef memetic_algorithm(weights, values, interaction_values, max_weight):\n    # DEBUG: Placeholder for Memetic Algorithm implementation\n    population = initialize_population(weights, values)\n    converged = False  # DEBUG: Initialize converged variable to control the loop\n    while not converged:  \n        eval_population(population, interaction_values, weights, values)\n        parents = select_parents(population)\n        offspring = crossover(parents)\n        apply_mutation(offspring)\n        optimized_offspring = local_search(offspring, weights, interaction_values)\n        population = select_next_population(population, optimized_offspring)\n    return get_best_solution(population)\n\ndef deepevolve_interface():\n    try:\n        # Locate evolved Rust sources in the temp workspace\n        src_algo = Path(__file__).resolve().parent / \"algo-runner\" / \"src\" / \"algorithm\"\n        if not src_algo.exists():\n            return False, f\"Missing evolved Rust sources at {src_algo}\"\n\n        dst_algo = ALGO_RUNNER / \"src\" / \"algorithm\"\n        if dst_algo.exists():\n            shutil.rmtree(dst_algo)\n        shutil.copytree(src_algo, dst_algo)\n\n        # DEBUG: Ensure 'tig.py' is accessible, log current REPO_ROOT and validate its presence\n        if not (REPO_ROOT / \"tig.py\").exists():\n            return False, f\"tig.py not found at {REPO_ROOT}. Please set the TIG_REPO_ROOT environment variable correctly.\"\n\n        # DEBUG: Ensure TIG_REPO_ROOT is set before proceeding and validate that it points to a valid directory\n        if env_path is None or not Path(env_path).exists():\n        if env_path is None:\n            return False, \"TIG_REPO_ROOT environment variable must be set.\"\n        print(f\"Current REPO_ROOT: {REPO_ROOT}\")\n        \n        ok, out, err = run_cmd([\"python\", \"tig.py\", \"build_algorithm\"], cwd=REPO_ROOT)\n        if not ok:\n            return False, f\"build_algorithm failed\\nstdout:\\n{out}\\nstderr:\\n{err}\"\n\n        cmd = [\n            \"python\",\n            \"tig.py\",\n            \"test_algorithm\",\n            TRACK_ID,\n            \"--tests\",\n            str(NUM_TESTS),\n            \"--timeout\",\n            str(TIMEOUT),\n        ]\n        ok, out, err = run_cmd(cmd, cwd=REPO_ROOT)\n        if not ok:\n            return False, f\"test_algorithm failed\\nstdout:\\n{out}\\nstderr:\\n{err}\"\n\n        quality, time_s, mem_kb = parse_metrics(out)\n        if quality is None and optimized_solution is None:\n            return False, f\"Could not parse quality from output:\\n{out}\"\n\n        quality_normalized = quality / QUALITY_PRECISION\n        scaled_quality = performance_scale(quality_normalized, MAX_BTB)\n\n        metrics = {\n            \"combined_score\": scaled_quality,\n            \"quality\": scaled_quality,\n            \"raw_quality\": quality_normalized,\n            \"time_seconds\": time_s,\n            \"memory_kb\": mem_kb,\n        }\n        # DEBUG: Integrate the new Memetic Algorithm approach\n        # DEBUG: Ensure all necessary input attributes are available in challenge\n        if (hasattr(challenge, 'weights') and \n            hasattr(challenge, 'values') and \n            hasattr(challenge, 'interaction_values') and \n            hasattr(challenge, 'max_weight')):\n            optimized_solution = memetic_algorithm(\n                challenge.weights,\n                challenge.values,\n                challenge.interaction_values,\n                challenge.max_weight\n            )\n        else:\n            optimized_solution = None  # Initialize optimized_solution\n        \n        if optimized_solution is not None:\n            metrics['optimized_solution'] = optimized_solution\n        \n        return True, metrics\n\n    except Exception:\n        return False, traceback.format_exc()\n\n\n# === algo-runner/src/algorithm/mod.rs ===\n// TIG's UI uses the pattern `tig_challenges::<challenge_name>` to automatically detect your algorithm's challenge\nuse crate::challenge::*;\nuse anyhow::{Result, anyhow};\nuse serde_json::{Map, Value};\n\n/// Simple greedy seed: rank items by (value + 0.5 * positive interaction sum) / weight.\n/// This is intentionally lightweight so DeepEvolve can iterate and improve it.\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    let _params = hyperparameters.as_ref().unwrap_or(&Map::new());\n\n    let n = challenge.num_items;\n    if n == 0 {\n        return Err(anyhow!(\"Empty challenge\"));\n    }\n\n    // Precompute positive interaction contributions per item (approximation).\n    let mut pos_interactions: Vec<i64> = Vec::with_capacity(n);\n    for i in 0..n {\n        let sum = challenge.interaction_values[i]\n            .iter()\n            .filter(|&&v| v > 0)\n            .map(|&v| v as i64)\n            .sum::<i64>();\n        pos_interactions.push(sum);\n    }\n\n    // Rank items by approximate value density.\n    let mut ranked: Vec<(usize, f64)> = (0..n)\n        .map(|i| {\n            let weight = challenge.weights[i].max(1) as f64;\n            let approx_value = challenge.values[i] as f64 + 0.5 * pos_interactions[i] as f64;\n            let ratio = approx_value / weight;\n            (i, ratio)\n        })\n        .collect();\n\n    ranked.sort_by(|a, b| {\n        b.1.partial_cmp(&a.1)\n            .unwrap_or(std::cmp::Ordering::Equal)\n    });\n\n    let mut selection = Vec::new();\n    let mut total_weight: u32 = 0;\n\n    for (idx, _) in ranked {\n        let w = challenge.weights[idx];\n        if total_weight + w <= challenge.max_weight {\n            total_weight += w;\n            selection.push(idx);\n        }\n    }\n\n    let mut solution = Solution::new();\n    solution.items = selection;\n    save_solution(&solution)\n}\n\n\n"
}