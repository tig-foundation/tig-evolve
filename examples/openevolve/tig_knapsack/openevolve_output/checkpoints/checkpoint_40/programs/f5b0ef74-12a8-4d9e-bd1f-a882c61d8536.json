{"id": "f5b0ef74-12a8-4d9e-bd1f-a882c61d8536", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "dfab6928-ae88-41a5-ab52-b891dc0b37f0", "generation": 1, "timestamp": 1766142070.520451, "iteration_found": 3, "metrics": {"avg_btb": -0.48269836, "combined_score": 0.0017301640000000006, "eval_time": 0.08226504800000001, "memory": 371200.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 24 lines with 220 lines", "parent_metrics": {"avg_btb": -0.48269836, "combined_score": 0.0017301640000000006, "eval_time": 0.076823763, "memory": 371200.0}, "island": 0}, "prompts": {"diff_user": {"system": "SETTING:\nYou are an expert Rust programmer specializing in combinatorial optimization algorithms with deep expertise in knapsack problems, resource allocation algorithms, and constraint satisfaction.\nYour mission is to evolve and optimize a quadratic knapsack algorithm that outputs the highest quality possible.\n\n\n=== CRITICAL OUTPUT FORMAT RULES ===\n1. Output ONLY raw Rust source code\n2. Include the complete file from first line to last line\n=== END OUTPUT FORMAT RULES ===\n\nAlgorithm Improvement Instructions:\n\nObjective\nImprove the knapsack algorithm to maximize the total value while respecting the weight constraint.\n\nCRITICAL Constraints\n- You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END\n- Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified\n- You MUST NOT modify the function signature\n- You MUST NOT modify lines before // EVOLVE-BLOCK-START\n- You MUST NOT modify lines after // EVOLVE-BLOCK-END\n- You MUST preserve the exact structure of code outside the evolve block\n\nInput: challenge parameter (type: &Challenge)\n\nThe challenge parameter provides access to the following fields with these EXPLICIT types:\n\n- challenge.seed: [u8; 32] - Fixed-size array of 32 bytes for seeding random number generators\n- challenge.weights: Vec<u32> - Vector of unsigned 32-bit integers representing each item's weight\n- challenge.values: Vec<u32> - Vector of unsigned 32-bit integers representing each item's base value\n- challenge.interaction_values: Vec<Vec<i32>> - 2D matrix (vector of vectors) of SIGNED 32-bit integers\n  - interaction_values[i][j] gives the bonus value when items i and j are BOTH selected\n  - This matrix is symmetric: interaction_values[i][j] == interaction_values[j][i]\n  - Diagonal is zero: interaction_values[i][i] == 0\n- challenge.max_weight: u32 - Unsigned 32-bit integer representing maximum total weight allowed\n  \nImportant notes:\n- All vectors have the same length (number of items)\n- challenge.weights.len() = challenge.values.len() = challenge.interaction_values.len()\n- Item indices are 0 to n-1 where n = challenge.values.len()\n- the structure of the algorithm i.e. the inputs and outputs are fixed, you can only modify the body of the algorithm.\n\nOutput: selected variable (type: Vec<usize>)\n\nYour code must create a variable named selected with the following specification:\n\n- Type: Vec<usize> (vector of unsigned size integers)\n- Content: Indices of items to include in the knapsack solution\n- Valid range: Each element must be in range [0, n-1] where n = challenge.values.len()\n- No duplicates: Each item index can appear at most once\n- Weight constraint: The sum of challenge.weights[i] for all i in selected must be \u2264 challenge.max_weight\n\nThe selected variable is automatically saved after the evolve block ends.\n\nContext:\n- This is a QUADRATIC knapsack problem with interaction values between items\n- Items have: weights, values, and interaction_values (2D matrix)\n- Total value = sum of item values + sum of interaction values for pairs of selected items\n- Constraint: total weight must not exceed max_weight which is half the weight of all items\n- The \"density\" of the knapsack is 25% - meaning interaction values in the symmetric interaction matrix are 0 with probability 0.75; otherwise a random number between 1 and 100.\n\nBENCHMARK:\n- Beat the state-of-the-art result of avg_btb = 0.0015.\n\nHyperparameters (Optional):\nIf your algorithm uses tunable parameters (e.g., iteration counts, thresholds, probabilities),\nyou can define them inside the EVOLVE-BLOCK. Follow these examples exactly.\n\nCRITICAL: The examples below show raw Rust code. Do NOT wrap them in markdown code fences.\n\n\nStep 1 - Define a Hyperparameters struct inside the EVOLVE-BLOCK:\n\n#[derive(Serialize, Deserialize)]\npub struct Hyperparameters {\n    pub max_iterations: usize,\n    pub temperature: f64,\n}\n\nStep 2 - Parse hyperparameters at the start of your code block:\n\nlet hyperparameters = match _hyperparameters {\n    Some(params) => {\n        serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n            .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n    }\n    None => Hyperparameters {\n        max_iterations: 100,\n        temperature: 0.95,\n    },\n};\n\nStep 3 - Use the hyperparameter values in your algorithm:\n\nfor _ in 0..hyperparameters.max_iterations {\n    // your algorithm logic here\n}\n\n\nRandom numbers:\nIf you need random numbers, recommend using SmallRng with challenge.seed:\nlet mut rng = SmallRng::from_seed(challenge.seed);\n\nMake sure you use\n- Optimised sorting strategies \n- Efficient data structures for tracking selected items\n\nImportant:\n- Only modify code within the EVOLVE-BLOCK\n- Ensure the algorithm terminates within reasonable time\n- Use the provided Challenge struct fields: values, weights, interaction_values, max_weight\n- The variable selected is automatically saved after the evolve block ends\n\nPERFORMANCE METRICS:\n1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)\n2. **combined_score**: progress toward beating the state-of-the-art benchmark\n3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)\n4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)\n\nTECHNICAL REQUIREMENTS:\n- **Error handling**: Graceful handling of optimization failures or infeasible configurations\n- **Memory efficiency**: Avoid excessive memory allocation for matrix computations\n", "user": "# Current Program Information\n- Fitness: 0.0017\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.0017\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: avg_btb: -0.4827, combined_score: 0.0017, eval_time: 0.0768, memory: 371200.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0017)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (-0.4827), Performs well on combined_score (0.0017), Performs well on eval_time (0.0768), Performs well on memory (371200.0000)\n\n\n\n# Current Program\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["This improvement replaces the simple linear greedy algorithm with Simulated Annealing (SA), a metaheuristic suitable for the Quadratic Knapsack Problem (QKP). SA incorporates the quadratic interaction values directly into the optimization process, allowing the algorithm to escape local optima and find higher-quality solutions.\n\nKey changes:\n1.  **Hyperparameters:** Introduced `max_iterations`, `initial_temperature`, and `cooling_rate` for tuning the SA process.\n2.  **State Management:** Uses a boolean vector (`is_selected`) for efficient state tracking and $O(1)$ lookups.\n3.  **Delta Calculation:** Implemented $O(N)$ helper closures (`calculate_delta_value_toggle`, `calculate_delta_swap`) to efficiently calculate the change in total quadratic value for Add/Remove and Swap moves, avoiding $O(N^2)$ recalculations in every step.\n4.  **Neighborhood Search:** Implemented Add/Remove (toggle) and Swap moves, ensuring feasibility (weight constraint) is maintained.\n5.  **Acceptance Criterion:** Uses the Metropolis criterion to accept worse solutions probabilistically, enabling exploration.\n\nThis approach significantly increases the likelihood of finding high-quality solutions compared to the initial purely linear greedy method.\n\n<<<<<<< SEARCH\n#[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n=======\n#[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_iterations: usize,\n        pub initial_temperature: f64,\n        pub cooling_rate: f64,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n        }\n        None => Hyperparameters {\n            max_iterations: 100_000, \n            initial_temperature: 5000.0, \n            cooling_rate: 0.9999, \n        },\n    };\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n    let n = challenge.values.len();\n    let max_weight = challenge.max_weight;\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n\n    // --- Helper Functions (Closures) ---\n\n    // Calculates the full quadratic value of a solution defined by is_selected\n    let calculate_full_value = |is_selected: &[bool]| -> i64 {\n        let mut total_value: i64 = 0;\n        for i in 0..n {\n            if is_selected[i] {\n                total_value += values[i] as i64;\n                for j in i + 1..n {\n                    if is_selected[j] {\n                        total_value += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        total_value\n    };\n\n    // Calculates the change in value if item `k` is toggled (added if currently false, removed if true)\n    let calculate_delta_value_toggle = |is_selected: &[bool], k: usize| -> i64 {\n        let mut delta: i64 = 0;\n        \n        if !is_selected[k] {\n            // Adding item k\n            delta += values[k] as i64;\n            for i in 0..n {\n                if i != k && is_selected[i] {\n                    delta += interactions[k][i] as i64;\n                }\n            }\n        } else {\n            // Removing item k\n            delta -= values[k] as i64;\n            for i in 0..n {\n                if i != k && is_selected[i] {\n                    delta -= interactions[k][i] as i64;\n                }\n            }\n        }\n        delta\n    };\n\n    // Calculates the change in value for swapping i (selected) and j (unselected)\n    let calculate_delta_swap = |is_selected: &[bool], i: usize, j: usize| -> i64 {\n        let mut delta: i64 = values[j] as i64 - values[i] as i64;\n\n        // Sum interaction changes with existing items k in S \\ {i, j}\n        for k in 0..n {\n            if k != i && k != j && is_selected[k] {\n                // I_{j, k} is gained, I_{i, k} is lost\n                delta += interactions[j][k] as i64;\n                delta -= interactions[i][k] as i64;\n            }\n        }\n        delta\n    };\n\n\n    // --- 1. Initial Solution (Greedy based on V/W ratio) ---\n    let mut items: Vec<usize> = (0..n).collect();\n    items.sort_by(|&a, &b| {\n        let w_a = weights[a] as f64;\n        let w_b = weights[b] as f64;\n        let ratio_a = if w_a > 0.0 { values[a] as f64 / w_a } else { f64::INFINITY };\n        let ratio_b = if w_b > 0.0 { values[b] as f64 / w_b } else { f64::INFINITY };\n        ratio_b.partial_cmp(&ratio_a).unwrap_or(std::cmp::Ordering::Equal)\n    });\n\n    let mut is_selected = vec![false; n];\n    let mut current_weight: u32 = 0;\n\n    for item_idx in items {\n        if current_weight + weights[item_idx] <= max_weight {\n            is_selected[item_idx] = true;\n            current_weight += weights[item_idx];\n        }\n    }\n\n    let mut current_value = calculate_full_value(&is_selected);\n    let mut best_value = current_value;\n    let mut best_is_selected = is_selected.clone();\n\n    let mut temperature = hyperparameters.initial_temperature;\n    let cooling_rate = hyperparameters.cooling_rate;\n\n    // --- 2. Simulated Annealing Loop ---\n    \n    for _ in 0..hyperparameters.max_iterations {\n        if temperature < 1e-6 {\n            break;\n        }\n\n        // 0: Add/Remove (Toggle), 1: Swap\n        let move_type = rng.gen_range(0..2); \n        \n        let mut next_is_selected = is_selected.clone();\n        let mut delta_value: i64 = 0;\n        let mut next_weight = current_weight;\n        let mut valid_move = false;\n\n        match move_type {\n            // 0: Add/Remove (Toggle a random item)\n            0 => {\n                let k = rng.gen_range(0..n);\n                let w_k = weights[k];\n\n                if is_selected[k] {\n                    // Remove k\n                    delta_value = calculate_delta_value_toggle(&is_selected, k);\n                    next_is_selected[k] = false;\n                    next_weight -= w_k;\n                    valid_move = true;\n                } else {\n                    // Add k\n                    if current_weight + w_k <= max_weight {\n                        delta_value = calculate_delta_value_toggle(&is_selected, k);\n                        next_is_selected[k] = true;\n                        next_weight += w_k;\n                        valid_move = true;\n                    }\n                }\n            }\n            // 1: Swap (Replace selected i with unselected j)\n            _ => {\n                // Find a selected item i and an unselected item j using limited attempts\n                let mut i = n;\n                let mut j = n;\n                \n                // Find i (selected)\n                for _ in 0..n {\n                    let candidate = rng.gen_range(0..n);\n                    if is_selected[candidate] {\n                        i = candidate;\n                        break;\n                    }\n                }\n                \n                // Find j (unselected)\n                for _ in 0..n {\n                    let candidate = rng.gen_range(0..n);\n                    if !is_selected[candidate] {\n                        j = candidate;\n                        break;\n                    }\n                }\n                \n                if i < n && j < n {\n                    let w_i = weights[i];\n                    let w_j = weights[j];\n                    \n                    let weight_diff = w_j as i64 - w_i as i64;\n                    \n                    if (current_weight as i64 + weight_diff) <= max_weight as i64 {\n                        delta_value = calculate_delta_swap(&is_selected, i, j);\n                        \n                        // Apply the swap\n                        next_is_selected[i] = false;\n                        next_is_selected[j] = true;\n                        next_weight = (current_weight as i64 + weight_diff) as u32;\n                        valid_move = true;\n                    }\n                }\n            }\n        }\n\n        if valid_move {\n            let accept_move = if delta_value > 0 {\n                true\n            } else if temperature > 0.0 {\n                // Metropolis criterion\n                let acceptance_prob = (delta_value as f64 / temperature).exp();\n                rng.gen::<f64>() < acceptance_prob\n            } else {\n                false\n            };\n\n            if accept_move {\n                current_value += delta_value;\n                current_weight = next_weight;\n                is_selected = next_is_selected;\n                \n                if current_value > best_value {\n                    best_value = current_value;\n                    best_is_selected = is_selected.clone();\n                }\n            }\n        }\n        \n        // Cooling schedule\n        temperature *= cooling_rate;\n    }\n\n    // Convert the best boolean vector back to indices\n    let selected: Vec<usize> = (0..n).filter(|&i| best_is_selected[i]).collect();\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}