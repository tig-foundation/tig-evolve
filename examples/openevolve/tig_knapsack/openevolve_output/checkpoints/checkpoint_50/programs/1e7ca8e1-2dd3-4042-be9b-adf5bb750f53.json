{"id": "1e7ca8e1-2dd3-4042-be9b-adf5bb750f53", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "f440304e-6227-4179-99c7-c195f45bf00c", "generation": 2, "timestamp": 1766143097.0495567, "iteration_found": 20, "metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.30749331, "memory": 371200.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 4}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}