{"id": "43d4fe2a-535a-4250-a551-88f752ab912c", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "65877930-4166-4c2f-9070-145a26f065ff", "generation": 3, "timestamp": 1766143813.205246, "iteration_found": 29, "metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.302997901, "memory": 371200.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 116 lines with 288 lines", "parent_metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.30749331, "memory": 371200.0}, "island": 3}, "prompts": {"diff_user": {"system": "SETTING:\nYou are an expert Rust programmer specializing in combinatorial optimization algorithms with deep expertise in knapsack problems, resource allocation algorithms, and constraint satisfaction.\nYour mission is to evolve and optimize a quadratic knapsack algorithm that outputs the highest quality possible.\n\n\n=== CRITICAL OUTPUT FORMAT RULES ===\n1. Output ONLY raw Rust source code\n2. Include the complete file from first line to last line\n=== END OUTPUT FORMAT RULES ===\n\nAlgorithm Improvement Instructions:\n\nObjective\nImprove the knapsack algorithm to maximize the total value while respecting the weight constraint.\n\nCRITICAL Constraints\n- You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END\n- Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified\n- You MUST NOT modify the function signature\n- You MUST NOT modify lines before // EVOLVE-BLOCK-START\n- You MUST NOT modify lines after // EVOLVE-BLOCK-END\n- You MUST preserve the exact structure of code outside the evolve block\n\nInput: challenge parameter (type: &Challenge)\n\nThe challenge parameter provides access to the following fields with these EXPLICIT types:\n\n- challenge.seed: [u8; 32] - Fixed-size array of 32 bytes for seeding random number generators\n- challenge.weights: Vec<u32> - Vector of unsigned 32-bit integers representing each item's weight\n- challenge.values: Vec<u32> - Vector of unsigned 32-bit integers representing each item's base value\n- challenge.interaction_values: Vec<Vec<i32>> - 2D matrix (vector of vectors) of SIGNED 32-bit integers\n  - interaction_values[i][j] gives the bonus value when items i and j are BOTH selected\n  - This matrix is symmetric: interaction_values[i][j] == interaction_values[j][i]\n  - Diagonal is zero: interaction_values[i][i] == 0\n- challenge.max_weight: u32 - Unsigned 32-bit integer representing maximum total weight allowed\n  \nImportant notes:\n- All vectors have the same length (number of items)\n- challenge.weights.len() = challenge.values.len() = challenge.interaction_values.len()\n- Item indices are 0 to n-1 where n = challenge.values.len()\n- the structure of the algorithm i.e. the inputs and outputs are fixed, you can only modify the body of the algorithm.\n\nOutput: selected variable (type: Vec<usize>)\n\nYour code must create a variable named selected with the following specification:\n\n- Type: Vec<usize> (vector of unsigned size integers)\n- Content: Indices of items to include in the knapsack solution\n- Valid range: Each element must be in range [0, n-1] where n = challenge.values.len()\n- No duplicates: Each item index can appear at most once\n- Weight constraint: The sum of challenge.weights[i] for all i in selected must be \u2264 challenge.max_weight\n\nThe selected variable is automatically saved after the evolve block ends.\n\nContext:\n- This is a QUADRATIC knapsack problem with interaction values between items\n- Items have: weights, values, and interaction_values (2D matrix)\n- Total value = sum of item values + sum of interaction values for pairs of selected items\n- Constraint: total weight must not exceed max_weight which is half the weight of all items\n- The \"density\" of the knapsack is 25% - meaning interaction values in the symmetric interaction matrix are 0 with probability 0.75; otherwise a random number between 1 and 100.\n\nBENCHMARK:\n- Beat the state-of-the-art result of avg_btb = 0.0015.\n\nHyperparameters (Optional):\nIf your algorithm uses tunable parameters (e.g., iteration counts, thresholds, probabilities),\nyou can define them inside the EVOLVE-BLOCK. Follow these examples exactly.\n\nCRITICAL: The examples below show raw Rust code. Do NOT wrap them in markdown code fences.\n\n\nStep 1 - Define a Hyperparameters struct inside the EVOLVE-BLOCK:\n\n#[derive(Serialize, Deserialize)]\npub struct Hyperparameters {\n    pub max_iterations: usize,\n    pub temperature: f64,\n}\n\nStep 2 - Parse hyperparameters at the start of your code block:\n\nlet hyperparameters = match _hyperparameters {\n    Some(params) => {\n        serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n            .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n    }\n    None => Hyperparameters {\n        max_iterations: 100,\n        temperature: 0.95,\n    },\n};\n\nStep 3 - Use the hyperparameter values in your algorithm:\n\nfor _ in 0..hyperparameters.max_iterations {\n    // your algorithm logic here\n}\n\n\nRandom numbers:\nIf you need random numbers, recommend using SmallRng with challenge.seed:\nlet mut rng = SmallRng::from_seed(challenge.seed);\n\nMake sure you use\n- Optimised sorting strategies \n- Efficient data structures for tracking selected items\n\nImportant:\n- Only modify code within the EVOLVE-BLOCK\n- Ensure the algorithm terminates within reasonable time\n- Use the provided Challenge struct fields: values, weights, interaction_values, max_weight\n- The variable selected is automatically saved after the evolve block ends\n\nPERFORMANCE METRICS:\n1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)\n2. **combined_score**: progress toward beating the state-of-the-art benchmark\n3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)\n4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)\n\nTECHNICAL REQUIREMENTS:\n- **Error handling**: Graceful handling of optimization failures or infeasible configurations\n- **Memory efficiency**: Avoid excessive memory allocation for matrix computations\n", "user": "# Current Program Information\n- Fitness: 0.3253\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.3253\n- Consider simplifying - code length exceeds 2000 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.3075, memory: 371200.0000\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Change 1: Replace 47 lines with 108 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.3147, memory: 371200.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            #[derive(Debug)]\n            enum Move {\n                Add(usize), // item_j index\n                Drop(usize), // selected_vec_idx\n                Swap(usize, usize), // selected_vec_idx_i, item_j index\n            }\n\n            loop {\n                let mut best_move: Option<Move> = None;\n                let mut max_delta: i64 = 0;\n\n                // --- 1. Search for Insertion (Add item j) ---\n                for item_j in 0..num_items {\n                    if !is_selected[item_j] {\n                        let item_weight = challenge.weights[item_j];\n                        if total_weight + item_weight <= challenge.max_weight {\n                            // Delta Value = Base Value + Sum of interactions with currently selected items\n                            let delta_value = challenge.values[item_j] as i64 + interaction_sums[item_j];\n\n                            if delta_value > max_delta {\n                                max_delta = delta_value;\n                                best_move = Some(Move::Add(item_j));\n                            }\n                        }\n                    }\n                }\n\n                // --- 2. Search for Removal (Drop item i) ---\n                // Note: Removal always reduces weight and increases capacity.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n\n                    // Delta Value = - (Base Value + Sum of interactions with currently selected items)\n                    let delta_value = -(challenge.values[item_i] as i64 + interaction_sums[item_i]);\n\n                    if delta_value > max_delta {\n                        max_delta = delta_value;\n                        best_move = Some(Move::Drop(i_vec_idx));\n                    }\n                }\n\n                // --- 3. Search for Swap (Drop item i, Add item j) ---\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        // Delta Value: (V_j - V_i) + (interaction_sums[j] - I_{j, i}) - interaction_sums[i]\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > max_delta {\n                            max_delta = delta_value;\n                            best_move = Some(Move::Swap(i_vec_idx, item_j));\n                        }\n                    }\n                }\n\n                // --- Execute Best Move ---\n                if max_delta > 0 {\n                    match best_move.unwrap() {\n                        Move::Add(item_j_to_add) => {\n                            let item_weight = challenge.weights[item_j_to_add];\n                            total_weight += item_weight;\n                            is_selected[item_j_to_add] = true;\n                            selected.push(item_j_to_add);\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] += challenge.interaction_values[k][item_j_to_add] as i64;\n                            }\n                        }\n                        Move::Drop(i_vec_idx_to_drop) => {\n                            let item_i_to_drop = selected.swap_remove(i_vec_idx_to_drop);\n                            total_weight -= challenge.weights[item_i_to_drop];\n                            is_selected[item_i_to_drop] = false;\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] -= challenge.interaction_values[k][item_i_to_drop] as i64;\n                            }\n                        }\n                        Move::Swap(i_vec_idx_to_swap, item_j_to_add) => {\n                            let item_i_to_drop = selected[i_vec_idx_to_swap];\n\n                            let delta_weight = challenge.weights[item_j_to_add] as i64 - challenge.weights[item_i_to_drop] as i64;\n                            total_weight = (total_weight as i64 + delta_weight) as u32;\n\n                            is_selected[item_i_to_drop] = false;\n                            is_selected[item_j_to_add] = true;\n                            selected[i_vec_idx_to_swap] = item_j_to_add;\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] += (challenge.interaction_values[k][item_j_to_add] - challenge.interaction_values[k][item_i_to_drop]) as i64;\n                            }\n                        }\n                    }\n                } else {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.3147), Performs well on memory (371200.0000)\n\n### Program 2 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.3075), Performs well on memory (371200.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            #[derive(Debug)]\n            enum Move {\n                Add(usize), // item_j index\n                Drop(usize), // selected_vec_idx\n                Swap(usize, usize), // selected_vec_idx_i, item_j index\n            }\n\n            loop {\n                let mut best_move: Option<Move> = None;\n                let mut max_delta: i64 = 0;\n\n                // --- 1. Search for Insertion (Add item j) ---\n                for item_j in 0..num_items {\n                    if !is_selected[item_j] {\n                        let item_weight = challenge.weights[item_j];\n                        if total_weight + item_weight <= challenge.max_weight {\n                            // Delta Value = Base Value + Sum of interactions with currently selected items\n                            let delta_value = challenge.values[item_j] as i64 + interaction_sums[item_j];\n\n                            if delta_value > max_delta {\n                                max_delta = delta_value;\n                                best_move = Some(Move::Add(item_j));\n                            }\n                        }\n                    }\n                }\n\n                // --- 2. Search for Removal (Drop item i) ---\n                // Note: Removal always reduces weight and increases capacity.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n\n                    // Delta Value = - (Base Value + Sum of interactions with currently selected items)\n                    let delta_value = -(challenge.values[item_i] as i64 + interaction_sums[item_i]);\n\n                    if delta_value > max_delta {\n                        max_delta = delta_value;\n                        best_move = Some(Move::Drop(i_vec_idx));\n                    }\n                }\n\n                // --- 3. Search for Swap (Drop item i, Add item j) ---\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        // Delta Value: (V_j - V_i) + (interaction_sums[j] - I_{j, i}) - interaction_sums[i]\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > max_delta {\n                            max_delta = delta_value;\n                            best_move = Some(Move::Swap(i_vec_idx, item_j));\n                        }\n                    }\n                }\n\n                // --- Execute Best Move ---\n                if max_delta > 0 {\n                    match best_move.unwrap() {\n                        Move::Add(item_j_to_add) => {\n                            let item_weight = challenge.weights[item_j_to_add];\n                            total_weight += item_weight;\n                            is_selected[item_j_to_add] = true;\n                            selected.push(item_j_to_add);\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] += challenge.interaction_values[k][item_j_to_add] as i64;\n                            }\n                        }\n                        Move::Drop(i_vec_idx_to_drop) => {\n                            let item_i_to_drop = selected.swap_remove(i_vec_idx_to_drop);\n                            total_weight -= challenge.weights[item_i_to_drop];\n                            is_selected[item_i_to_drop] = false;\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] -= challenge.interaction_values[k][item_i_to_drop] as i64;\n                            }\n                        }\n                        Move::Swap(i_vec_idx_to_swap, item_j_to_add) => {\n                            let item_i_to_drop = selected[i_vec_idx_to_swap];\n\n                            let delta_weight = challenge.weights[item_j_to_add] as i64 - challenge.weights[item_i_to_drop] as i64;\n                            total_weight = (total_weight as i64 + delta_weight) as u32;\n\n                            is_selected[item_i_to_drop] = false;\n                            is_selected[item_j_to_add] = true;\n                            selected[i_vec_idx_to_swap] = item_j_to_add;\n\n                            // Update interaction_sums efficiently in O(N).\n                            for k in 0..num_items {\n                                interaction_sums[k] += (challenge.interaction_values[k][item_j_to_add] - challenge.interaction_values[k][item_i_to_drop]) as i64;\n                            }\n                        }\n                    }\n                } else {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 47 lines with 108 lines, Alternative avg_btb approach, Excellent memory (371200.000)\n\n# Current Program\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["This improvement introduces Iterated Local Search (ILS) wrapped around the robust 1-opt local search (Add, Drop, Swap moves). This strategy aims to escape local optima found by the initial greedy heuristic by periodically perturbing the current best solution and re-optimizing it, significantly increasing the chances of finding higher quality solutions.\n\nThe changes involve:\n1. Defining hyperparameters for ILS iterations and perturbation size.\n2. Defining helper closures for calculating the total value and performing the Local Search (LS).\n3. Running the initial deterministic greedy construction.\n4. Applying LS to the initial solution.\n5. Iterating the ILS loop: Perturb (random drops + greedy refill) -> LS -> Update best solution.\n\n<<<<<<< SEARCH\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n=======\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub ils_iterations: usize,\n        pub perturbation_size: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or_else(|_| Hyperparameters {\n                    ils_iterations: 5,\n                    perturbation_size: 5,\n                })\n        }\n        None => Hyperparameters {\n            ils_iterations: 5,\n            perturbation_size: 5,\n        },\n    };\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // Helper to calculate total value based on selected items and pre-calculated interaction sums\n    let calculate_value = |current_selected: &[usize], current_interaction_sums: &[i64]| -> i64 {\n        let mut total_value: i64 = 0;\n        \n        // Base values\n        for &i in current_selected {\n            total_value += challenge.values[i] as i64;\n        }\n\n        // Interaction values: 0.5 * sum_{i in S} interaction_sums[i]\n        let mut interaction_sum_total: i64 = 0;\n        for &i in current_selected {\n            interaction_sum_total += current_interaction_sums[i];\n        }\n        \n        // Since I is symmetric and I[i][i]=0, interaction_sum_total counts every pair interaction twice.\n        total_value += interaction_sum_total / 2;\n        total_value\n    };\n\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items == 0 {\n        // Handle empty case early\n        return Ok(());\n    }\n\n    // Define the Local Search (LS) function closure\n    let local_search = |\n        initial_selected: Vec<usize>, \n        initial_total_weight: u32, \n        initial_is_selected: Vec<bool>\n    | -> (Vec<usize>, u32, Vec<bool>, i64) {\n\n        let mut selected = initial_selected;\n        let mut total_weight = initial_total_weight;\n        let mut is_selected = initial_is_selected;\n\n        // Calculate initial interaction sums\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        #[derive(Debug)]\n        enum Move {\n            Add(usize), \n            Drop(usize), \n            Swap(usize, usize), \n        }\n\n        loop {\n            let mut best_move: Option<Move> = None;\n            let mut max_delta: i64 = 0;\n\n            // --- 1. Search for Insertion (Add item j) ---\n            for item_j in 0..num_items {\n                if !is_selected[item_j] {\n                    let item_weight = challenge.weights[item_j];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let delta_value = challenge.values[item_j] as i64 + interaction_sums[item_j];\n\n                        if delta_value > max_delta {\n                            max_delta = delta_value;\n                            best_move = Some(Move::Add(item_j));\n                        }\n                    }\n                }\n            }\n\n            // --- 2. Search for Removal (Drop item i) ---\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                let delta_value = -(challenge.values[item_i] as i64 + interaction_sums[item_i]);\n\n                if delta_value > max_delta {\n                    max_delta = delta_value;\n                    best_move = Some(Move::Drop(i_vec_idx));\n                }\n            }\n\n            // --- 3. Search for Swap (Drop item i, Add item j) ---\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > max_delta {\n                        max_delta = delta_value;\n                        best_move = Some(Move::Swap(i_vec_idx, item_j));\n                    }\n                }\n            }\n\n            // --- Execute Best Move ---\n            if max_delta > 0 {\n                match best_move.unwrap() {\n                    Move::Add(item_j_to_add) => {\n                        let item_weight = challenge.weights[item_j_to_add];\n                        total_weight += item_weight;\n                        is_selected[item_j_to_add] = true;\n                        selected.push(item_j_to_add);\n\n                        for k in 0..num_items {\n                            interaction_sums[k] += challenge.interaction_values[k][item_j_to_add] as i64;\n                        }\n                    }\n                    Move::Drop(i_vec_idx_to_drop) => {\n                        let item_i_to_drop = selected.swap_remove(i_vec_idx_to_drop);\n                        total_weight -= challenge.weights[item_i_to_drop];\n                        is_selected[item_i_to_drop] = false;\n\n                        for k in 0..num_items {\n                            interaction_sums[k] -= challenge.interaction_values[k][item_i_to_drop] as i64;\n                        }\n                    }\n                    Move::Swap(i_vec_idx_to_swap, item_j_to_add) => {\n                        let item_i_to_drop = selected[i_vec_idx_to_swap];\n\n                        let delta_weight = challenge.weights[item_j_to_add] as i64 - challenge.weights[item_i_to_drop] as i64;\n                        total_weight = (total_weight as i64 + delta_weight) as u32;\n\n                        is_selected[item_i_to_drop] = false;\n                        is_selected[item_j_to_add] = true;\n                        selected[i_vec_idx_to_swap] = item_j_to_add;\n\n                        for k in 0..num_items {\n                            interaction_sums[k] += (challenge.interaction_values[k][item_j_to_add] - challenge.interaction_values[k][item_i_to_drop]) as i64;\n                        }\n                    }\n                }\n            } else {\n                break; // Local optimum reached.\n            }\n        }\n        \n        // Calculate final value\n        let final_value = calculate_value(&selected, &interaction_sums);\n        (selected, total_weight, is_selected, final_value)\n    };\n\n    // --- Phase 1: Initial Greedy Construction ---\n    let (initial_selected, initial_total_weight, initial_is_selected) = {\n        let mut selected = Vec::new();\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n        (selected, total_weight, is_selected)\n    };\n\n    // --- Phase 2: Iterated Local Search (ILS) ---\n    \n    // Start with the deterministic greedy solution + LS\n    let (mut best_selected, mut best_total_weight, mut best_is_selected, mut best_value) = \n        local_search(initial_selected, initial_total_weight, initial_is_selected);\n\n    let mut current_selected = best_selected.clone();\n    let mut current_total_weight = best_total_weight;\n    let mut current_is_selected = best_is_selected.clone();\n\n    for _iter in 0..hyperparameters.ils_iterations {\n        \n        // 2a. Perturbation: Randomly drop K items\n        let k = hyperparameters.perturbation_size.min(current_selected.len());\n        \n        // Items to drop (indices within `current_selected`)\n        let mut drop_indices: Vec<usize> = (0..current_selected.len()).collect();\n        rng.shuffle(&mut drop_indices);\n        \n        let mut items_to_drop = Vec::with_capacity(k);\n        for i in 0..k {\n            items_to_drop.push(drop_indices[i]);\n        }\n        items_to_drop.sort_unstable_by(|a, b| b.cmp(a)); // Drop from end first to maintain index validity\n\n        for i_vec_idx in items_to_drop {\n            let item_i = current_selected.swap_remove(i_vec_idx);\n            current_total_weight -= challenge.weights[item_i];\n            current_is_selected[item_i] = false;\n        }\n\n        // 2b. Re-insertion (Greedy fill based on base value/weight ratio)\n        let mut candidates: Vec<usize> = (0..num_items).filter(|&i| !current_is_selected[i]).collect();\n        candidates.sort_unstable_by(|&a, &b| {\n            let ratio_a = challenge.values[a] as f64 / challenge.weights[a].max(1) as f64;\n            let ratio_b = challenge.values[b] as f64 / challenge.weights[b].max(1) as f64;\n            // Sort descending\n            ratio_b.partial_cmp(&ratio_a).unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        for item_j in candidates {\n            if current_total_weight + challenge.weights[item_j] <= challenge.max_weight {\n                current_selected.push(item_j);\n                current_is_selected[item_j] = true;\n                current_total_weight += challenge.weights[item_j];\n            }\n        }\n\n        // 2c. Local Search\n        let (next_selected, next_total_weight, next_is_selected, next_value) = \n            local_search(current_selected, current_total_weight, current_is_selected);\n\n        // 2d. Acceptance Criterion (Simple: Always accept if better than global best)\n        if next_value > best_value {\n            best_value = next_value;\n            best_selected = next_selected.clone();\n            best_total_weight = next_total_weight;\n            best_is_selected = next_is_selected.clone();\n        }\n\n        // Update current solution for next iteration (simple acceptance)\n        current_selected = next_selected;\n        current_total_weight = next_total_weight;\n        current_is_selected = next_is_selected;\n    }\n\n    let selected = best_selected;\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}