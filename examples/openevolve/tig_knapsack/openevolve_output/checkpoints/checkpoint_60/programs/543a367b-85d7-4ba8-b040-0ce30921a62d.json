{"id": "543a367b-85d7-4ba8-b040-0ce30921a62d", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    // Phase 1: Greedy construction using marginal density.\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    let gain = marginal_gains[i];\n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "cdd152d0-d3cb-4e56-87a6-26131052cc45", "generation": 2, "timestamp": 1766142677.2744513, "iteration_found": 13, "metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.295830589, "memory": 371200.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 45 lines with 90 lines", "parent_metrics": {"avg_btb": -0.00092497, "combined_score": 0.049907503, "eval_time": 0.172104548, "memory": 371200.0}, "island": 0}, "prompts": {"diff_user": {"system": "SETTING:\nYou are an expert Rust programmer specializing in combinatorial optimization algorithms with deep expertise in knapsack problems, resource allocation algorithms, and constraint satisfaction.\nYour mission is to evolve and optimize a quadratic knapsack algorithm that outputs the highest quality possible.\n\n\n=== CRITICAL OUTPUT FORMAT RULES ===\n1. Output ONLY raw Rust source code\n2. Include the complete file from first line to last line\n=== END OUTPUT FORMAT RULES ===\n\nAlgorithm Improvement Instructions:\n\nObjective\nImprove the knapsack algorithm to maximize the total value while respecting the weight constraint.\n\nCRITICAL Constraints\n- You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END\n- Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified\n- You MUST NOT modify the function signature\n- You MUST NOT modify lines before // EVOLVE-BLOCK-START\n- You MUST NOT modify lines after // EVOLVE-BLOCK-END\n- You MUST preserve the exact structure of code outside the evolve block\n\nInput: challenge parameter (type: &Challenge)\n\nThe challenge parameter provides access to the following fields with these EXPLICIT types:\n\n- challenge.seed: [u8; 32] - Fixed-size array of 32 bytes for seeding random number generators\n- challenge.weights: Vec<u32> - Vector of unsigned 32-bit integers representing each item's weight\n- challenge.values: Vec<u32> - Vector of unsigned 32-bit integers representing each item's base value\n- challenge.interaction_values: Vec<Vec<i32>> - 2D matrix (vector of vectors) of SIGNED 32-bit integers\n  - interaction_values[i][j] gives the bonus value when items i and j are BOTH selected\n  - This matrix is symmetric: interaction_values[i][j] == interaction_values[j][i]\n  - Diagonal is zero: interaction_values[i][i] == 0\n- challenge.max_weight: u32 - Unsigned 32-bit integer representing maximum total weight allowed\n  \nImportant notes:\n- All vectors have the same length (number of items)\n- challenge.weights.len() = challenge.values.len() = challenge.interaction_values.len()\n- Item indices are 0 to n-1 where n = challenge.values.len()\n- the structure of the algorithm i.e. the inputs and outputs are fixed, you can only modify the body of the algorithm.\n\nOutput: selected variable (type: Vec<usize>)\n\nYour code must create a variable named selected with the following specification:\n\n- Type: Vec<usize> (vector of unsigned size integers)\n- Content: Indices of items to include in the knapsack solution\n- Valid range: Each element must be in range [0, n-1] where n = challenge.values.len()\n- No duplicates: Each item index can appear at most once\n- Weight constraint: The sum of challenge.weights[i] for all i in selected must be \u2264 challenge.max_weight\n\nThe selected variable is automatically saved after the evolve block ends.\n\nContext:\n- This is a QUADRATIC knapsack problem with interaction values between items\n- Items have: weights, values, and interaction_values (2D matrix)\n- Total value = sum of item values + sum of interaction values for pairs of selected items\n- Constraint: total weight must not exceed max_weight which is half the weight of all items\n- The \"density\" of the knapsack is 25% - meaning interaction values in the symmetric interaction matrix are 0 with probability 0.75; otherwise a random number between 1 and 100.\n\nBENCHMARK:\n- Beat the state-of-the-art result of avg_btb = 0.0015.\n\nHyperparameters (Optional):\nIf your algorithm uses tunable parameters (e.g., iteration counts, thresholds, probabilities),\nyou can define them inside the EVOLVE-BLOCK. Follow these examples exactly.\n\nCRITICAL: The examples below show raw Rust code. Do NOT wrap them in markdown code fences.\n\n\nStep 1 - Define a Hyperparameters struct inside the EVOLVE-BLOCK:\n\n#[derive(Serialize, Deserialize)]\npub struct Hyperparameters {\n    pub max_iterations: usize,\n    pub temperature: f64,\n}\n\nStep 2 - Parse hyperparameters at the start of your code block:\n\nlet hyperparameters = match _hyperparameters {\n    Some(params) => {\n        serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n            .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n    }\n    None => Hyperparameters {\n        max_iterations: 100,\n        temperature: 0.95,\n    },\n};\n\nStep 3 - Use the hyperparameter values in your algorithm:\n\nfor _ in 0..hyperparameters.max_iterations {\n    // your algorithm logic here\n}\n\n\nRandom numbers:\nIf you need random numbers, recommend using SmallRng with challenge.seed:\nlet mut rng = SmallRng::from_seed(challenge.seed);\n\nMake sure you use\n- Optimised sorting strategies \n- Efficient data structures for tracking selected items\n\nImportant:\n- Only modify code within the EVOLVE-BLOCK\n- Ensure the algorithm terminates within reasonable time\n- Use the provided Challenge struct fields: values, weights, interaction_values, max_weight\n- The variable selected is automatically saved after the evolve block ends\n\nPERFORMANCE METRICS:\n1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)\n2. **combined_score**: progress toward beating the state-of-the-art benchmark\n3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)\n4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)\n\nTECHNICAL REQUIREMENTS:\n- **Error handling**: Graceful handling of optimization failures or infeasible configurations\n- **Memory efficiency**: Avoid excessive memory allocation for matrix computations\n", "user": "# Current Program Information\n- Fitness: 0.0499\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.0499\n- Consider simplifying - code length exceeds 2000 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 24 lines with 57 lines\n- Metrics: avg_btb: -0.0009, combined_score: 0.0499, eval_time: 0.1716, memory: 371200.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 58 lines with 199 lines\n- Metrics: avg_btb: -0.0008, combined_score: 0.0499, eval_time: 124.2267, memory: 393696.0000\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Change 1: Replace 65 lines with 116 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.3075, memory: 371200.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.3075), Performs well on memory (371200.0000)\n\n### Program 2 (Score: 0.0499)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub sa_iterations: usize,\n        pub initial_temp: f64,\n        pub cooling_rate: f64,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n        }\n        None => Hyperparameters {\n            sa_iterations: 100_000, // Increased iterations for better quality\n            initial_temp: 1000.0, \n            cooling_rate: 0.9999, // Slower cooling for deeper search\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let max_weight = challenge.max_weight as u64;\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // --- Helper Functions ---\n\n    // Calculate the total value of a selection\n    fn calculate_value(\n        selected: &std::collections::HashSet<usize>,\n        values: &[u32],\n        interactions: &[Vec<i32>],\n    ) -> i64 {\n        let mut total_value: i64 = 0;\n\n        for &i in selected.iter() {\n            total_value += values[i] as i64;\n            for &j in selected.iter() {\n                if i < j {\n                    total_value += interactions[i][j] as i64;\n                }\n            }\n        }\n        total_value\n    }\n\n    // --- 1. Initial Solution (Greedy Marginal Density) ---\n    \n    let mut current_selected_vec = Vec::new();\n    let mut current_weight: u64 = 0;\n    let mut is_selected = vec![false; num_items];\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                if current_weight + weights[i] as u64 <= max_weight {\n                    let weight = weights[i];\n                    let gain = marginal_gains[i];\n                    \n                    let density = if weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            current_selected_vec.push(idx_to_add);\n            current_weight += weights[idx_to_add] as u64;\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += interactions[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    \n    // Convert initial solution to HashSet for efficient SA lookups\n    let mut current_set: std::collections::HashSet<usize> = current_selected_vec.into_iter().collect();\n    let mut current_value = calculate_value(&current_set, values, interactions);\n    \n    let mut best_set = current_set.clone();\n    let mut best_value = current_value;\n    \n    let mut current_temp = hyperparameters.initial_temp;\n\n    // --- 2. Simulated Annealing Refinement ---\n    \n    for _ in 0..hyperparameters.sa_iterations {\n        let mut next_set = current_set.clone();\n        let mut next_weight = current_weight;\n        let mut delta_value: i64 = 0;\n        let mut valid_move = false;\n\n        // Pre-calculate items in/out for random selection\n        let items_in: Vec<usize> = current_set.iter().cloned().collect();\n        let items_out: Vec<usize> = (0..num_items).filter(|i| !current_set.contains(i)).collect();\n        \n        // Move selection priority: Swap > Add > Remove\n        let move_type = rng.gen_range(0..100);\n\n        if move_type < 50 && !items_in.is_empty() && !items_out.is_empty() { \n            // 50% chance: Try 2-opt swap\n            let i_in = items_in[rng.gen_range(0..items_in.len())];\n            let i_out = items_out[rng.gen_range(0..items_out.len())];\n            \n            let weight_diff = weights[i_out] as i64 - weights[i_in] as i64;\n\n            if (next_weight as i64 + weight_diff) <= max_weight as i64 {\n                \n                // Calculate value change for swap: Add i_out, Remove i_in\n                delta_value = (values[i_out] as i64 - values[i_in] as i64);\n                \n                // Interactions with items remaining in the set (S \\ {i_in})\n                for &j in &current_set {\n                    if j != i_in {\n                        delta_value += interactions[i_out][j] as i64;\n                        delta_value -= interactions[i_in][j] as i64;\n                    }\n                }\n                \n                next_set.remove(&i_in);\n                next_set.insert(i_out);\n                next_weight = (next_weight as i64 + weight_diff) as u64;\n                valid_move = true;\n            }\n        } else if move_type < 80 && !items_out.is_empty() { \n            // 30% chance: Try 1-opt addition\n            let i_out = items_out[rng.gen_range(0..items_out.len())];\n            \n            if current_weight + weights[i_out] as u64 <= max_weight {\n                // Calculate value change for addition\n                delta_value = values[i_out] as i64;\n                for &j in &current_set {\n                    delta_value += interactions[i_out][j] as i64;\n                }\n                \n                next_set.insert(i_out);\n                next_weight += weights[i_out] as u64;\n                valid_move = true;\n            }\n        } else if !items_in.is_empty() { \n            // 20% chance: Try 1-opt removal\n            let i_in = items_in[rng.gen_range(0..items_in.len())];\n\n            // Calculate value change for removal\n            delta_value = -(values[i_in] as i64);\n            for &j in &current_set {\n                if i_in != j {\n                    delta_value -= interactions[i_in][j] as i64;\n                }\n            }\n            \n            next_set.remove(&i_in);\n            next_weight -= weights[i_in] as u64;\n            valid_move = true;\n        }\n\n        if valid_move {\n            let next_value = current_value + delta_value;\n\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / current_temp) {\n                // Accept move\n                current_set = next_set;\n                current_value = next_value;\n                current_weight = next_weight;\n\n                if current_value > best_value {\n                    best_value = current_value;\n                    best_set = current_set.clone();\n                }\n            }\n        }\n\n        // Cooling schedule\n        current_temp *= hyperparameters.cooling_rate;\n        current_temp = current_temp.max(1e-6); \n    }\n\n    // Final result conversion\n    let selected: Vec<usize> = best_set.into_iter().collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (-0.0008), Performs well on combined_score (0.0499), Performs well on eval_time (124.2267), Performs well on memory (393696.0000)\n\n### Program 3 (Score: 0.0499)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values.\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u64 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                if current_weight + challenge.weights[i] as u64 <= challenge.max_weight as u64 {\n                    let weight = challenge.weights[i];\n                    let gain = marginal_gains[i];\n                    \n                    let density = if weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add] as u64;\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (-0.0009), Performs well on combined_score (0.0499), Performs well on eval_time (0.1716), Performs well on memory (371200.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0499)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // This implements a greedy constructive heuristic for the Quadratic Knapsack Problem.\n    // The algorithm iteratively adds the item with the highest \"marginal density\"\n    // to the solution. The marginal density is the item's marginal value (its base\n    // value plus the sum of interaction values with items already in the knapsack)\n    // divided by its weight. This approach is more sophisticated than a simple\n    // value-to-weight ratio as it accounts for the quadratic interaction terms.\n    \n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n\n    // Use a boolean mask to efficiently track which items are not yet selected.\n    let mut unselected_mask: Vec<bool> = vec![true; num_items];\n\n    // `marginal_gains[i]` stores `values[i] + sum(interaction_values[i][j])` for all `j`\n    // currently in `selected`. We use i64 to prevent potential overflow from summing u32 and i32.\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        // Find the unselected item with the best marginal density that still fits.\n        for i in 0..num_items {\n            if unselected_mask[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    // Guard against division by zero, though weights are typically positive.\n                    if item_weight > 0 {\n                        let density = marginal_gains[i] as f64 / item_weight as f64;\n                        if density > best_density {\n                            best_density = density;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n        }\n\n        if let Some(item_to_add) = best_item {\n            // Add the best item to the solution.\n            selected.push(item_to_add);\n            current_weight += challenge.weights[item_to_add];\n            unselected_mask[item_to_add] = false;\n\n            // Update the marginal gains of remaining unselected items. This is an O(N) step.\n            // When an item is added, the potential value of adding other items changes.\n            for i in 0..num_items {\n                if unselected_mask[i] {\n                    marginal_gains[i] += challenge.interaction_values[item_to_add][i] as i64;\n                }\n            }\n        } else {\n            // If no item can be added (either none fit or all are considered), we're done.\n            break;\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0499)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 65 lines with 116 lines, Alternative avg_btb approach, Excellent memory (371200.000)\n\n### Inspiration 2 (Score: 0.0017, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Alternative avg_btb approach, Alternative combined_score approach, Alternative eval_time approach\n\n### Inspiration 3 (Score: 0.0494, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_iterations: usize,\n        pub initial_temperature: f64,\n        pub cooling_rate: f64,\n        pub swap_probability: f64,\n    }\n\n    // Initialize hyperparameters, prioritizing provided values or using robust defaults for Simulated Annealing\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or_else(|_| Hyperparameters {\n                    max_iterations: 1_000_000,\n                    initial_temperature: 500.0,\n                    cooling_rate: 0.99999,\n                    swap_probability: 0.6,\n                })\n        }\n        None => Hyperparameters {\n            max_iterations: 1_000_000,\n            initial_temperature: 500.0,\n            cooling_rate: 0.99999,\n            swap_probability: 0.6,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let max_weight = challenge.max_weight;\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // --- Helper function to calculate total value (O(N^2)) ---\n    #[inline]\n    fn calculate_value(\n        is_selected: &[bool],\n        values: &[u32],\n        interactions: &[Vec<i32>],\n        n: usize,\n    ) -> i64 {\n        let mut total_value: i64 = 0;\n        for i in 0..n {\n            if is_selected[i] {\n                total_value += values[i] as i64;\n                for j in (i + 1)..n {\n                    if is_selected[j] {\n                        total_value += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        total_value\n    }\n\n    // --- Initialization: Linear Greedy Heuristic ---\n    let mut current_is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n\n    // Sort by V/W ratio for initial feasible solution\n    let mut items_sorted: Vec<usize> = (0..num_items).collect();\n    items_sorted.sort_by(|&a, &b| {\n        let ratio_a = values[a] as f64 / weights[a] as f64;\n        let ratio_b = values[b] as f64 / weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap_or(std::cmp::Ordering::Equal)\n    });\n\n    for item_idx in items_sorted {\n        if current_weight.checked_add(weights[item_idx]).map_or(false, |w| w <= max_weight) {\n            current_is_selected[item_idx] = true;\n            current_weight += weights[item_idx];\n        }\n    }\n\n    let mut current_value = calculate_value(&current_is_selected, values, interactions, num_items);\n    let mut best_is_selected = current_is_selected.clone();\n    let mut best_value = current_value;\n\n    // Pre-calculate selected/unselected indices for fast random access\n    let mut selected_indices: Vec<usize> = (0..num_items).filter(|&i| current_is_selected[i]).collect();\n    let mut unselected_indices: Vec<usize> = (0..num_items).filter(|&i| !current_is_selected[i]).collect();\n\n    // --- Simulated Annealing Loop ---\n    let mut temp = hyperparameters.initial_temperature;\n    let cooling_rate = hyperparameters.cooling_rate;\n    let swap_prob = hyperparameters.swap_probability;\n\n    for _ in 0..hyperparameters.max_iterations {\n        if temp < 1e-8 {\n            break;\n        }\n\n        let move_type = rng.gen::<f64>();\n        let mut delta_value: i64 = 0;\n        let new_weight: u32;\n        \n        // 1. Determine Move Type: Swap, Add, or Remove\n        if move_type < swap_prob && !selected_indices.is_empty() && !unselected_indices.is_empty() {\n            // --- SWAP MOVE (O(N)) ---\n            let k_out_idx = rng.gen_range(0..selected_indices.len());\n            let k_out = selected_indices[k_out_idx];\n\n            let k_in_idx = rng.gen_range(0..unselected_indices.len());\n            let k_in = unselected_indices[k_in_idx];\n\n            let w_in = weights[k_in];\n            let w_out = weights[k_out];\n            \n            // Check weight feasibility\n            if w_in <= w_out {\n                new_weight = current_weight - w_out + w_in;\n            } else {\n                if let Some(w) = current_weight.checked_sub(w_out).and_then(|w| w.checked_add(w_in)) {\n                    if w <= max_weight {\n                        new_weight = w;\n                    } else {\n                        continue; // Infeasible swap\n                    }\n                } else {\n                    continue; // Overflow/Infeasible\n                }\n            }\n\n            // Calculate incremental value change\n            delta_value = values[k_in] as i64 - values[k_out] as i64;\n\n            // Interaction change: Sum_{i in S\\{k_out}} (I_{k_in, i} - I_{k_out, i})\n            for &i in &selected_indices {\n                if i != k_out {\n                    delta_value += interactions[k_in][i] as i64;\n                    delta_value -= interactions[k_out][i] as i64;\n                }\n            }\n            \n            // Acceptance criterion (Metropolis)\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept swap\n                current_is_selected[k_out] = false;\n                current_is_selected[k_in] = true;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.swap_remove(k_out_idx);\n                selected_indices.push(k_in);\n                unselected_indices.swap_remove(k_in_idx);\n                unselected_indices.push(k_out);\n            }\n\n        } else if move_type < (swap_prob + (1.0 - swap_prob) / 2.0) && !unselected_indices.is_empty() {\n            // --- ADD MOVE (O(N)) ---\n            let k_in_idx = rng.gen_range(0..unselected_indices.len());\n            let k_in = unselected_indices[k_in_idx];\n\n            if let Some(w) = current_weight.checked_add(weights[k_in]) {\n                if w <= max_weight {\n                    new_weight = w;\n                } else {\n                    continue; // Infeasible add\n                }\n            } else {\n                continue; // Overflow\n            }\n\n            // Calculate incremental value change: V_in + Sum_{i in S} I_{k_in, i}\n            delta_value = values[k_in] as i64;\n            for &i in &selected_indices {\n                delta_value += interactions[k_in][i] as i64;\n            }\n\n            // Acceptance criterion\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept add\n                current_is_selected[k_in] = true;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.push(k_in);\n                unselected_indices.swap_remove(k_in_idx);\n            }\n\n        } else if !selected_indices.is_empty() {\n            // --- REMOVE MOVE (O(N)) ---\n            let k_out_idx = rng.gen_range(0..selected_indices.len());\n            let k_out = selected_indices[k_out_idx];\n\n            new_weight = current_weight - weights[k_out]; // Always feasible\n\n            // Calculate incremental value change: -V_out - Sum_{i in S\\{k_out}} I_{k_out, i}\n            delta_value = -(values[k_out] as i64);\n            for &i in &selected_indices {\n                if i != k_out {\n                    delta_value -= interactions[k_out][i] as i64;\n                }\n            }\n\n            // Acceptance criterion\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept remove\n                current_is_selected[k_out] = false;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.swap_remove(k_out_idx);\n                unselected_indices.push(k_out);\n            }\n        }\n\n        // Update best solution found so far\n        if current_value > best_value {\n            best_value = current_value;\n            best_is_selected.copy_from_slice(&current_is_selected);\n        }\n\n        // Cooling schedule\n        temp *= cooling_rate;\n    }\n\n    // Final selection based on the best solution found\n    let selected: Vec<usize> = (0..num_items)\n        .filter(|&i| best_is_selected[i])\n        .collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 24 lines with 226 lines, Alternative avg_btb approach, Alternative combined_score approach\n\n# Current Program\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["My analysis indicates that the current program, a greedy constructive heuristic, can be significantly improved. Its primary weakness is that once an item is added to the knapsack, the decision is final. This can lead to suboptimal solutions, as early greedy choices may prevent better overall combinations later on.\n\nThe top-performing inspiration program (`Program 1`) demonstrates a powerful two-phase strategy: first, it builds a good initial solution with a greedy heuristic (similar to the current program), and second, it refines that solution using a local search algorithm. The local search repeatedly swaps items (one in, one out) to find better combinations until no further improvement is possible.\n\nI will adopt this proven two-phase approach. By adding a local search refinement phase after the initial greedy construction, the algorithm can escape the local optima where the simple greedy approach gets stuck. This change directly targets the quality of the final solution, aiming for a substantial increase in the `avg_btb` score. The local search implementation is carefully designed for efficiency, using pre-calculated interaction sums and incremental updates to evaluate swaps quickly.\n\n<<<<<<< SEARCH\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n=======\n    // Phase 1: Greedy construction using marginal density.\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    let gain = marginal_gains[i];\n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}