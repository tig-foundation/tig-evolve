{"id": "f51d7344-19dc-4c2f-b3b1-9ff84b10a11e", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 100, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 100,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove delta values and O(1) updates to MG array.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Best Improvement, O(L * N^2)) ---\n    \n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        // Weight check: current_weight - w_j + w_i <= max_weight\n                        let new_weight_i64 = current_weight as i64 - w_j as i64 + w_i as i64;\n                        \n                        if new_weight_i64 >= 0 && new_weight_i64 <= max_weight as i64 {\n                            // Delta V(j out, i in) = MG[i] - MG[j] - interactions[i][j]\n                            let delta_v_swap = marginal_gains[i] - marginal_gains[j] - interactions[i][j] as i64;\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = (current_weight as i64 - weights[j] as i64 + weights[i] as i64) as u32;\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "18ac172c-065f-4aac-a4fd-af045988237e", "generation": 2, "timestamp": 1766145556.0121856, "iteration_found": 47, "metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.268299353, "memory": 371200.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 24 lines with 179 lines", "parent_metrics": {"avg_btb": -0.48269836, "combined_score": 0.0017301640000000006, "eval_time": 0.081577502, "memory": 371200.0}, "island": 0}, "prompts": {"diff_user": {"system": "SETTING:\nYou are an expert Rust programmer specializing in combinatorial optimization algorithms with deep expertise in knapsack problems, resource allocation algorithms, and constraint satisfaction.\nYour mission is to evolve and optimize a quadratic knapsack algorithm that outputs the highest quality possible.\n\n\n=== CRITICAL OUTPUT FORMAT RULES ===\n1. Output ONLY raw Rust source code\n2. Include the complete file from first line to last line\n=== END OUTPUT FORMAT RULES ===\n\nAlgorithm Improvement Instructions:\n\nObjective\nImprove the knapsack algorithm to maximize the total value while respecting the weight constraint.\n\nCRITICAL Constraints\n- You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END\n- Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified\n- You MUST NOT modify the function signature\n- You MUST NOT modify lines before // EVOLVE-BLOCK-START\n- You MUST NOT modify lines after // EVOLVE-BLOCK-END\n- You MUST preserve the exact structure of code outside the evolve block\n\nInput: challenge parameter (type: &Challenge)\n\nThe challenge parameter provides access to the following fields with these EXPLICIT types:\n\n- challenge.seed: [u8; 32] - Fixed-size array of 32 bytes for seeding random number generators\n- challenge.weights: Vec<u32> - Vector of unsigned 32-bit integers representing each item's weight\n- challenge.values: Vec<u32> - Vector of unsigned 32-bit integers representing each item's base value\n- challenge.interaction_values: Vec<Vec<i32>> - 2D matrix (vector of vectors) of SIGNED 32-bit integers\n  - interaction_values[i][j] gives the bonus value when items i and j are BOTH selected\n  - This matrix is symmetric: interaction_values[i][j] == interaction_values[j][i]\n  - Diagonal is zero: interaction_values[i][i] == 0\n- challenge.max_weight: u32 - Unsigned 32-bit integer representing maximum total weight allowed\n  \nImportant notes:\n- All vectors have the same length (number of items)\n- challenge.weights.len() = challenge.values.len() = challenge.interaction_values.len()\n- Item indices are 0 to n-1 where n = challenge.values.len()\n- the structure of the algorithm i.e. the inputs and outputs are fixed, you can only modify the body of the algorithm.\n\nOutput: selected variable (type: Vec<usize>)\n\nYour code must create a variable named selected with the following specification:\n\n- Type: Vec<usize> (vector of unsigned size integers)\n- Content: Indices of items to include in the knapsack solution\n- Valid range: Each element must be in range [0, n-1] where n = challenge.values.len()\n- No duplicates: Each item index can appear at most once\n- Weight constraint: The sum of challenge.weights[i] for all i in selected must be \u2264 challenge.max_weight\n\nThe selected variable is automatically saved after the evolve block ends.\n\nContext:\n- This is a QUADRATIC knapsack problem with interaction values between items\n- Items have: weights, values, and interaction_values (2D matrix)\n- Total value = sum of item values + sum of interaction values for pairs of selected items\n- Constraint: total weight must not exceed max_weight which is half the weight of all items\n- The \"density\" of the knapsack is 25% - meaning interaction values in the symmetric interaction matrix are 0 with probability 0.75; otherwise a random number between 1 and 100.\n\nBENCHMARK:\n- Beat the state-of-the-art result of avg_btb = 0.0015.\n\nHyperparameters (Optional):\nIf your algorithm uses tunable parameters (e.g., iteration counts, thresholds, probabilities),\nyou can define them inside the EVOLVE-BLOCK. Follow these examples exactly.\n\nCRITICAL: The examples below show raw Rust code. Do NOT wrap them in markdown code fences.\n\n\nStep 1 - Define a Hyperparameters struct inside the EVOLVE-BLOCK:\n\n#[derive(Serialize, Deserialize)]\npub struct Hyperparameters {\n    pub max_iterations: usize,\n    pub temperature: f64,\n}\n\nStep 2 - Parse hyperparameters at the start of your code block:\n\nlet hyperparameters = match _hyperparameters {\n    Some(params) => {\n        serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n            .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n    }\n    None => Hyperparameters {\n        max_iterations: 100,\n        temperature: 0.95,\n    },\n};\n\nStep 3 - Use the hyperparameter values in your algorithm:\n\nfor _ in 0..hyperparameters.max_iterations {\n    // your algorithm logic here\n}\n\n\nRandom numbers:\nIf you need random numbers, recommend using SmallRng with challenge.seed:\nlet mut rng = SmallRng::from_seed(challenge.seed);\n\nMake sure you use\n- Optimised sorting strategies \n- Efficient data structures for tracking selected items\n\nImportant:\n- Only modify code within the EVOLVE-BLOCK\n- Ensure the algorithm terminates within reasonable time\n- Use the provided Challenge struct fields: values, weights, interaction_values, max_weight\n- The variable selected is automatically saved after the evolve block ends\n\nPERFORMANCE METRICS:\n1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)\n2. **combined_score**: progress toward beating the state-of-the-art benchmark\n3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)\n4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)\n\nTECHNICAL REQUIREMENTS:\n- **Error handling**: Graceful handling of optimization failures or infeasible configurations\n- **Memory efficiency**: Avoid excessive memory allocation for matrix computations\n", "user": "# Current Program Information\n- Fitness: 0.0017\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.3253 \u2192 0.0017. Consider revising recent changes.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 24 lines with 181 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.2465, memory: 371200.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 16 lines with 22 lines\nChange 2: Replace 108 lines with 150 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 11.5252, memory: 380204.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 5 lines with 66 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.3127, memory: 371200.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        // interaction_sums[i] = Sum of interaction values between item i and all currently selected items k.\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            // Iterate over all possible 1-opt swaps (i out, j in) using a best-improvement strategy.\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx]; // Item to remove\n                for item_j in 0..num_items { // Item to add\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    // Efficiently calculate the change in total value for the swap.\n                    // Delta V = (V[j] - V[i]) + (Sum_{k in S, k!=i} I(j, k)) - (Sum_{k in S, k!=i} I(i, k))\n                    // This is equivalent to: V[j] - V[i] + (interaction_sums[j] - I(j,i)) - (interaction_sums[i] - I(i,i))\n                    // Since I(i,i) is 0, it simplifies to the expression below.\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                // Execute the best swap found.\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                // Update interaction_sums efficiently in O(N) instead of recalculating.\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                // No more profitable swaps exist; local optimum reached.\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.3127), Performs well on memory (371200.0000)\n\n### Program 2 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_iterations: usize,\n        pub initial_temperature: f64,\n        pub cooling_rate: f64,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_iterations: 500, // Reduced iterations for safer O(N^2) complexity\n                    initial_temperature: 100.0,\n                    cooling_rate: 0.99,\n                })\n        }\n        None => Hyperparameters {\n            max_iterations: 500,\n            initial_temperature: 100.0,\n            cooling_rate: 0.99,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Simulated Annealing, O(L * N^2)) ---\n    \n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // Calculate initial value V0\n    let mut current_value = {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n    \n    let mut best_solution = is_selected.clone();\n    let mut best_value = current_value;\n\n    #[derive(Debug, Clone, Copy, PartialEq)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n        None,\n    }\n\n    let mut temperature = hyperparameters.initial_temperature;\n    let cooling_rate = hyperparameters.cooling_rate;\n    let max_iterations = hyperparameters.max_iterations;\n\n    for _ in 0..max_iterations {\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: LS_Move = LS_Move::None;\n\n        // O(N^2) Best Improvement search for the current iteration\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = LS_Move::Remove(j);\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = MG[i] - interactions[i][j] - MG[j]\n                            let delta_v_swap = marginal_gains[i] - interactions[i][j] as i64 - marginal_gains[j];\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = LS_Move::Swap(j, i);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = LS_Move::Add(i);\n                    }\n                }\n            }\n        }\n\n        // --- SA Acceptance Criterion ---\n        let accept_move = match best_move {\n            LS_Move::None => false,\n            _ => {\n                if best_delta_v > 0 {\n                    true // Always accept improving moves\n                } else if temperature > 1e-6 {\n                    // Accept non-improving moves probabilistically\n                    let acceptance_prob = (-best_delta_v as f64 / temperature).exp();\n                    rng.gen::<f64>() < acceptance_prob\n                } else {\n                    false\n                }\n            }\n        };\n\n        // --- Execute Accepted Move ---\n        if accept_move {\n            current_value += best_delta_v;\n\n            match best_move {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::None => {}\n            }\n            \n            // Update best solution found so far\n            if current_value > best_value {\n                best_value = current_value;\n                best_solution = is_selected.clone();\n            }\n        }\n\n        // Cooling schedule\n        if temperature > 1e-6 { \n            temperature *= cooling_rate;\n        }\n    }\n    \n    // Use the best solution found during the SA run\n    is_selected = best_solution;\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (11.5252), Performs well on memory (380204.0000)\n\n### Program 3 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 50, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 50,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Best Improvement, O(L * N^2)) ---\n    \n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        // Weight check: current_weight - w_j + w_i <= max_weight\n                        // Since j is selected, current_weight >= w_j.\n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = MG[i] - interactions[i][j] - MG[j]\n                            let delta_v_swap = marginal_gains[i] - interactions[i][j] as i64 - marginal_gains[j];\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.2465), Performs well on memory (371200.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    // Phase 1: Greedy construction using marginal density.\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    let gain = marginal_gains[i];\n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n### Program D2 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: An O(N^2) greedy algorithm that considers interaction values.\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        // Pre-calculate the sum of interactions for each item with the current solution.\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        #[derive(Debug, Clone, Copy)]\n        enum LS_Move {\n            Add(usize), // item_j\n            Remove(usize, usize), // (item_i, i_vec_idx)\n            Swap(usize, usize, usize), // (item_i, item_j, i_vec_idx)\n        }\n\n        loop {\n            let mut best_delta_v = 0i64;\n            let mut best_move: Option<LS_Move> = None; \n\n            // 1. Check Add moves (j in)\n            for j in 0..num_items {\n                if !is_selected[j] {\n                    let w_j = challenge.weights[j];\n                    if current_weight.checked_add(w_j).map_or(false, |w| w <= challenge.max_weight) {\n                        // Delta V = V[j] + interaction_sums[j]\n                        let delta_v_add = challenge.values[j] as i64 + interaction_sums[j];\n\n                        if delta_v_add > best_delta_v {\n                            best_delta_v = delta_v_add;\n                            best_move = Some(LS_Move::Add(j));\n                        }\n                    }\n                }\n            }\n\n            // 2. Check Remove and Swap moves (i out)\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n\n                // --- Remove Move (i out) ---\n                // Delta V = - (V[i] + interaction_sums[i])\n                let delta_v_remove = -(challenge.values[item_i] as i64 + interaction_sums[item_i]);\n\n                if delta_v_remove > best_delta_v {\n                    best_delta_v = delta_v_remove;\n                    best_move = Some(LS_Move::Remove(item_i, i_vec_idx));\n                }\n\n                // --- Swap Moves (i out, j in) ---\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    // Delta V calculation for swapping i out and j in:\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > best_delta_v {\n                        best_delta_v = delta_value;\n                        best_move = Some(LS_Move::Swap(item_i, item_j, i_vec_idx));\n                    }\n                }\n            }\n\n            if best_delta_v > 0 {\n                // Execute Best Move\n                match best_move.unwrap() {\n                    LS_Move::Add(item_j) => {\n                        is_selected[item_j] = true;\n                        current_weight += challenge.weights[item_j];\n                        selected.push(item_j); \n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] += challenge.interaction_values[k][item_j] as i64;\n                        }\n                    }\n                    LS_Move::Remove(item_i, i_vec_idx) => {\n                        is_selected[item_i] = false;\n                        current_weight -= challenge.weights[item_i];\n                        \n                        // Remove from the selected vector by swapping with the last element\n                        selected.swap_remove(i_vec_idx);\n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] -= challenge.interaction_values[k][item_i] as i64;\n                        }\n                    }\n                    LS_Move::Swap(item_i, item_j, i_vec_idx) => {\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        current_weight = (current_weight as i64 + delta_weight) as u32;\n                        \n                        is_selected[item_i] = false;\n                        is_selected[item_j] = true;\n                        selected[i_vec_idx] = item_j; // Replace item_i with item_j in the selected vector\n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] += (challenge.interaction_values[k][item_j] - challenge.interaction_values[k][item_i]) as i64;\n                        }\n                    }\n                }\n            } else {\n                // No more improving moves found, local optimum reached.\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: Iterative greedy construction heuristic.\n    // At each step, it adds the item with the highest marginal gain-to-weight ratio.\n    let num_items = challenge.values.len();\n    let mut selected = Vec::new();\n\n    if num_items > 0 {\n        let mut total_weight: u32 = 0;\n        let mut is_selected = vec![false; num_items];\n        let mut marginal_gains: Vec<f64> = challenge.values.iter().map(|&v| v as f64).collect();\n\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_ratio = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = challenge.weights[i];\n                    if total_weight + item_weight <= challenge.max_weight {\n                        let ratio = if item_weight > 0 {\n                            marginal_gains[i] / item_weight as f64\n                        } else {\n                            if marginal_gains[i] > 0.0 {\n                                f64::INFINITY\n                            } else {\n                                f64::NEG_INFINITY\n                            }\n                        };\n\n                        if ratio > best_ratio {\n                            best_ratio = ratio;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(item_to_add) = best_item {\n                selected.push(item_to_add);\n                is_selected[item_to_add] = true;\n                total_weight += challenge.weights[item_to_add];\n\n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        marginal_gains[i] += challenge.interaction_values[item_to_add][i] as f64;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n        // This phase iterates and performs the best possible swap (one item in, one item out)\n        // until no further improvements can be made.\n        if !selected.is_empty() {\n            let mut interaction_sums = vec![0i64; num_items];\n            for i in 0..num_items {\n                for &k in &selected {\n                    interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n                }\n            }\n\n            loop {\n                let mut improvement_found = false;\n                let mut best_swap: Option<(usize, usize, i64)> = None; // (selected_vec_idx, item_j_idx, delta_value)\n\n                // Best-improvement strategy: find the best possible swap in the entire 1-opt neighborhood.\n                for i_vec_idx in 0..selected.len() {\n                    let item_i = selected[i_vec_idx];\n                    for item_j in 0..num_items {\n                        if is_selected[item_j] { continue; }\n\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        if (total_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                            continue;\n                        }\n\n                        let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                        + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                        - interaction_sums[item_i];\n\n                        if delta_value > 0 {\n                            if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                                best_swap = Some((i_vec_idx, item_j, delta_value));\n                            }\n                        }\n                    }\n                }\n\n                if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                    let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                    let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                    total_weight = (total_weight as i64 + delta_weight) as u32;\n                    is_selected[item_i_to_swap] = false;\n                    is_selected[item_j_to_swap] = true;\n                    selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                    // Update interaction_sums efficiently in O(N).\n                    for k in 0..num_items {\n                        interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                    }\n                    improvement_found = true;\n                }\n\n                if !improvement_found {\n                    break; // Local optimum reached.\n                }\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 65 lines with 116 lines, Alternative avg_btb approach, Excellent memory (371200.000)\n\n### Inspiration 2 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        // interaction_sums[i] = Sum of interaction values between item i and all currently selected items k.\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            // Iterate over all possible 1-opt swaps (i out, j in) using a best-improvement strategy.\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx]; // Item to remove\n                for item_j in 0..num_items { // Item to add\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    // Efficiently calculate the change in total value for the swap.\n                    // Delta V = (V[j] - V[i]) + (Sum_{k in S, k!=i} I(j, k)) - (Sum_{k in S, k!=i} I(i, k))\n                    // This is equivalent to: V[j] - V[i] + (interaction_sums[j] - I(j,i)) - (interaction_sums[i] - I(i,i))\n                    // Since I(i,i) is 0, it simplifies to the expression below.\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                // Execute the best swap found.\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                // Update interaction_sums efficiently in O(N) instead of recalculating.\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                // No more profitable swaps exist; local optimum reached.\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 5 lines with 66 lines, Alternative avg_btb approach, Excellent memory (371200.000)\n\n### Inspiration 3 (Score: 0.0494, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_iterations: usize,\n        pub initial_temperature: f64,\n        pub cooling_rate: f64,\n        pub swap_probability: f64,\n    }\n\n    // Initialize hyperparameters, prioritizing provided values or using robust defaults for Simulated Annealing\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or_else(|_| Hyperparameters {\n                    max_iterations: 1_000_000,\n                    initial_temperature: 500.0,\n                    cooling_rate: 0.99999,\n                    swap_probability: 0.6,\n                })\n        }\n        None => Hyperparameters {\n            max_iterations: 1_000_000,\n            initial_temperature: 500.0,\n            cooling_rate: 0.99999,\n            swap_probability: 0.6,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let max_weight = challenge.max_weight;\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // --- Helper function to calculate total value (O(N^2)) ---\n    #[inline]\n    fn calculate_value(\n        is_selected: &[bool],\n        values: &[u32],\n        interactions: &[Vec<i32>],\n        n: usize,\n    ) -> i64 {\n        let mut total_value: i64 = 0;\n        for i in 0..n {\n            if is_selected[i] {\n                total_value += values[i] as i64;\n                for j in (i + 1)..n {\n                    if is_selected[j] {\n                        total_value += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        total_value\n    }\n\n    // --- Initialization: Linear Greedy Heuristic ---\n    let mut current_is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n\n    // Sort by V/W ratio for initial feasible solution\n    let mut items_sorted: Vec<usize> = (0..num_items).collect();\n    items_sorted.sort_by(|&a, &b| {\n        let ratio_a = values[a] as f64 / weights[a] as f64;\n        let ratio_b = values[b] as f64 / weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap_or(std::cmp::Ordering::Equal)\n    });\n\n    for item_idx in items_sorted {\n        if current_weight.checked_add(weights[item_idx]).map_or(false, |w| w <= max_weight) {\n            current_is_selected[item_idx] = true;\n            current_weight += weights[item_idx];\n        }\n    }\n\n    let mut current_value = calculate_value(&current_is_selected, values, interactions, num_items);\n    let mut best_is_selected = current_is_selected.clone();\n    let mut best_value = current_value;\n\n    // Pre-calculate selected/unselected indices for fast random access\n    let mut selected_indices: Vec<usize> = (0..num_items).filter(|&i| current_is_selected[i]).collect();\n    let mut unselected_indices: Vec<usize> = (0..num_items).filter(|&i| !current_is_selected[i]).collect();\n\n    // --- Simulated Annealing Loop ---\n    let mut temp = hyperparameters.initial_temperature;\n    let cooling_rate = hyperparameters.cooling_rate;\n    let swap_prob = hyperparameters.swap_probability;\n\n    for _ in 0..hyperparameters.max_iterations {\n        if temp < 1e-8 {\n            break;\n        }\n\n        let move_type = rng.gen::<f64>();\n        let mut delta_value: i64 = 0;\n        let new_weight: u32;\n        \n        // 1. Determine Move Type: Swap, Add, or Remove\n        if move_type < swap_prob && !selected_indices.is_empty() && !unselected_indices.is_empty() {\n            // --- SWAP MOVE (O(N)) ---\n            let k_out_idx = rng.gen_range(0..selected_indices.len());\n            let k_out = selected_indices[k_out_idx];\n\n            let k_in_idx = rng.gen_range(0..unselected_indices.len());\n            let k_in = unselected_indices[k_in_idx];\n\n            let w_in = weights[k_in];\n            let w_out = weights[k_out];\n            \n            // Check weight feasibility\n            if w_in <= w_out {\n                new_weight = current_weight - w_out + w_in;\n            } else {\n                if let Some(w) = current_weight.checked_sub(w_out).and_then(|w| w.checked_add(w_in)) {\n                    if w <= max_weight {\n                        new_weight = w;\n                    } else {\n                        continue; // Infeasible swap\n                    }\n                } else {\n                    continue; // Overflow/Infeasible\n                }\n            }\n\n            // Calculate incremental value change\n            delta_value = values[k_in] as i64 - values[k_out] as i64;\n\n            // Interaction change: Sum_{i in S\\{k_out}} (I_{k_in, i} - I_{k_out, i})\n            for &i in &selected_indices {\n                if i != k_out {\n                    delta_value += interactions[k_in][i] as i64;\n                    delta_value -= interactions[k_out][i] as i64;\n                }\n            }\n            \n            // Acceptance criterion (Metropolis)\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept swap\n                current_is_selected[k_out] = false;\n                current_is_selected[k_in] = true;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.swap_remove(k_out_idx);\n                selected_indices.push(k_in);\n                unselected_indices.swap_remove(k_in_idx);\n                unselected_indices.push(k_out);\n            }\n\n        } else if move_type < (swap_prob + (1.0 - swap_prob) / 2.0) && !unselected_indices.is_empty() {\n            // --- ADD MOVE (O(N)) ---\n            let k_in_idx = rng.gen_range(0..unselected_indices.len());\n            let k_in = unselected_indices[k_in_idx];\n\n            if let Some(w) = current_weight.checked_add(weights[k_in]) {\n                if w <= max_weight {\n                    new_weight = w;\n                } else {\n                    continue; // Infeasible add\n                }\n            } else {\n                continue; // Overflow\n            }\n\n            // Calculate incremental value change: V_in + Sum_{i in S} I_{k_in, i}\n            delta_value = values[k_in] as i64;\n            for &i in &selected_indices {\n                delta_value += interactions[k_in][i] as i64;\n            }\n\n            // Acceptance criterion\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept add\n                current_is_selected[k_in] = true;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.push(k_in);\n                unselected_indices.swap_remove(k_in_idx);\n            }\n\n        } else if !selected_indices.is_empty() {\n            // --- REMOVE MOVE (O(N)) ---\n            let k_out_idx = rng.gen_range(0..selected_indices.len());\n            let k_out = selected_indices[k_out_idx];\n\n            new_weight = current_weight - weights[k_out]; // Always feasible\n\n            // Calculate incremental value change: -V_out - Sum_{i in S\\{k_out}} I_{k_out, i}\n            delta_value = -(values[k_out] as i64);\n            for &i in &selected_indices {\n                if i != k_out {\n                    delta_value -= interactions[k_out][i] as i64;\n                }\n            }\n\n            // Acceptance criterion\n            if delta_value > 0 || rng.gen::<f64>() < f64::exp(delta_value as f64 / temp) {\n                // Accept remove\n                current_is_selected[k_out] = false;\n                current_weight = new_weight;\n                current_value += delta_value;\n\n                // Update index vectors\n                selected_indices.swap_remove(k_out_idx);\n                unselected_indices.push(k_out);\n            }\n        }\n\n        // Update best solution found so far\n        if current_value > best_value {\n            best_value = current_value;\n            best_is_selected.copy_from_slice(&current_is_selected);\n        }\n\n        // Cooling schedule\n        temp *= cooling_rate;\n    }\n\n    // Final selection based on the best solution found\n    let selected: Vec<usize> = (0..num_items)\n        .filter(|&i| best_is_selected[i])\n        .collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 24 lines with 226 lines, Alternative avg_btb approach, Alternative combined_score approach\n\n# Current Program\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["The current program uses a naive greedy approach based solely on the base value/weight ratio, ignoring the critical quadratic interaction terms. This leads to poor performance on the Quadratic Knapsack Problem (QKP).\n\nI will replace the entire block with a standard, high-performing QKP heuristic:\n1. **QKP-Aware Greedy Construction:** Select items based on the marginal density (marginal gain / weight), where marginal gain includes interactions with already selected items.\n2. **Best Improvement Local Search (BILS):** Iteratively search the 1-opt neighborhood (Add, Remove, Swap) for the move offering the highest positive value gain, using efficient $O(N)$ updates for marginal gains.\n\nThis approach, demonstrated in previous high-scoring attempts (e.g., Program 3), is known to achieve strong results for QKP instances.\n\n<<<<<<< SEARCH\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n    \n    // Simple greedy: sort by value/weight ratio (ignoring interactions)\n    let num_items = challenge.values.len();\n\n    let mut items: Vec<usize> = (0..num_items).collect();\n    items.sort_by(|&a, &b| {\n        let ratio_a = challenge.values[a] as f64 / challenge.weights[a] as f64;\n        let ratio_b = challenge.values[b] as f64 / challenge.weights[b] as f64;\n        ratio_b.partial_cmp(&ratio_a).unwrap()\n    });\n    \n    let mut selected = Vec::new();\n    let mut total_weight: u32 = 0;\n    \n    for item_idx in items {\n        if total_weight + challenge.weights[item_idx] <= challenge.max_weight {\n            selected.push(item_idx);\n            total_weight += challenge.weights[item_idx];\n        }\n    }\n=======\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 100, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 100,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove delta values and O(1) updates to MG array.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Best Improvement, O(L * N^2)) ---\n    \n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        // Weight check: current_weight - w_j + w_i <= max_weight\n                        let new_weight_i64 = current_weight as i64 - w_j as i64 + w_i as i64;\n                        \n                        if new_weight_i64 >= 0 && new_weight_i64 <= max_weight as i64 {\n                            // Delta V(j out, i in) = MG[i] - MG[j] - interactions[i][j]\n                            let delta_v_swap = marginal_gains[i] - marginal_gains[j] - interactions[i][j] as i64;\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = (current_weight as i64 - weights[j] as i64 + weights[i] as i64) as u32;\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}