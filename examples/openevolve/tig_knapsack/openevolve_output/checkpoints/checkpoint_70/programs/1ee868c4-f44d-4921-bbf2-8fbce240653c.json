{"id": "1ee868c4-f44d-4921-bbf2-8fbce240653c", "code": "// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_restarts: usize,\n        pub perturbation_size: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_restarts: 10, // Increased restarts for better exploration\n                    perturbation_size: 5, \n                })\n        }\n        None => Hyperparameters {\n            max_restarts: 10,\n            perturbation_size: 5,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // --- State Variables (Current Solution) ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n    let mut current_value: i64 = 0;\n\n    // --- Best Solution Tracking ---\n    let mut best_solution = vec![false; num_items];\n    let mut best_value = i64::MIN;\n\n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    // Helper function to run Best Improvement Local Search (BILS) until convergence\n    // Modifies state variables in place.\n    let mut run_bils = |\n        is_selected: &mut Vec<bool>,\n        current_weight: &mut u32,\n        marginal_gains: &mut Vec<i64>,\n        current_value: &mut i64\n    | {\n        loop {\n            let mut best_delta_v = 0i64;\n            let mut best_move: Option<LS_Move> = None;\n\n            // O(N^2) neighborhood search\n            for j in 0..num_items {\n                if is_selected[j] {\n                    // Item j is selected: Check Remove and Swap moves involving j\n\n                    // --- Remove Move (j out) ---\n                    let delta_v_remove_j = -marginal_gains[j];\n                    if delta_v_remove_j > best_delta_v {\n                        best_delta_v = delta_v_remove_j;\n                        best_move = Some(LS_Move::Remove(j));\n                    }\n\n                    // --- Swap Moves (j out, i in) ---\n                    let w_j = weights[j];\n                    \n                    for i in 0..num_items {\n                        if !is_selected[i] {\n                            let w_i = weights[i];\n                            \n                            // Check weight constraint for swap\n                            let delta_w = w_i as i64 - w_j as i64;\n                            if (*current_weight as i64 + delta_w) <= max_weight as i64 {\n                                \n                                // Delta V(j out, i in) = -MG[j] + (MG[i] - interactions[i][j])\n                                let delta_v_swap = delta_v_remove_j + marginal_gains[i] - interactions[i][j] as i64;\n\n                                if delta_v_swap > best_delta_v {\n                                    best_delta_v = delta_v_swap;\n                                    best_move = Some(LS_Move::Swap(j, i));\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    // Item i is unselected: Check Add moves\n                    let i = j;\n                    let w_i = weights[i];\n\n                    // --- Add Move (i in) ---\n                    if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                        let delta_v_add_i = marginal_gains[i];\n\n                        if delta_v_add_i > best_delta_v {\n                            best_delta_v = delta_v_add_i;\n                            best_move = Some(LS_Move::Add(i));\n                        }\n                    }\n                }\n            }\n\n            if best_delta_v > 0 {\n                *current_value += best_delta_v;\n\n                match best_move.unwrap() {\n                    LS_Move::Add(i) => {\n                        is_selected[i] = true;\n                        *current_weight += weights[i];\n                        for k in 0..num_items {\n                            marginal_gains[k] += interactions[i][k] as i64;\n                        }\n                    }\n                    LS_Move::Remove(j) => {\n                        is_selected[j] = false;\n                        *current_weight -= weights[j];\n                        for k in 0..num_items {\n                            marginal_gains[k] -= interactions[j][k] as i64;\n                        }\n                    }\n                    LS_Move::Swap(j, i) => {\n                        is_selected[j] = false;\n                        is_selected[i] = true;\n                        *current_weight = *current_weight - weights[j] + weights[i];\n                        for k in 0..num_items {\n                            marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                        }\n                    }\n                }\n            } else {\n                break; // Local optimum reached\n            }\n        }\n    };\n\n    // Helper function to calculate current value from scratch\n    let calculate_current_value = |is_selected: &[bool]| -> i64 {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n    \n    // Helper function to calculate marginal gains from scratch\n    let calculate_marginal_gains = |is_selected: &[bool]| -> Vec<i64> {\n        let mut mg: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n        for i in 0..num_items {\n            if is_selected[i] {\n                for k in 0..num_items {\n                    mg[k] += interactions[i][k] as i64;\n                }\n            }\n        }\n        mg\n    };\n\n    // --- 1. Initial Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n    \n    // Initialize current_value after greedy phase\n    current_value = calculate_current_value(&is_selected);\n    best_value = current_value;\n    best_solution = is_selected.clone();\n\n    // --- 2. Iterated Local Search (ILS) ---\n    for restart in 0..hyperparameters.max_restarts {\n        \n        // A. Run BILS on the current state until local optimum is reached\n        run_bils(&mut is_selected, &mut current_weight, &mut marginal_gains, &mut current_value);\n\n        // B. Update Best Solution\n        if current_value > best_value {\n            best_value = current_value;\n            best_solution = is_selected.clone();\n        }\n\n        if restart == hyperparameters.max_restarts - 1 {\n            break; // No need to perturb after the last optimization run\n        }\n\n        // C. Perturbation Phase (Randomly remove items + Greedy Repair)\n        let selected_indices: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n        let num_selected = selected_indices.len();\n        \n        let p_size = hyperparameters.perturbation_size.min(num_selected);\n        \n        // 1. Randomly remove P_size items\n        let mut items_to_remove = Vec::with_capacity(p_size);\n        let mut temp_selected = selected_indices.clone();\n        \n        for _ in 0..p_size {\n            if temp_selected.is_empty() { break; }\n            let idx_in_temp = rng.gen_range(0..temp_selected.len());\n            let item_j = temp_selected.swap_remove(idx_in_temp);\n            items_to_remove.push(item_j);\n        }\n\n        for j in items_to_remove {\n            if is_selected[j] {\n                is_selected[j] = false;\n                current_weight -= weights[j];\n            }\n        }\n\n        // 2. Recalculate state variables (MG and Value) based on the perturbed solution\n        current_value = calculate_current_value(&is_selected);\n        marginal_gains = calculate_marginal_gains(&is_selected);\n\n        // 3. Greedy Repair (Add items back based on marginal density)\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_density: f64 = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = weights[i];\n                    if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                        let gain = marginal_gains[i];\n                        \n                        let density = if item_weight == 0 {\n                            if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                        } else {\n                            gain as f64 / item_weight as f64\n                        };\n\n                        if density > best_density {\n                            best_density = density;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(idx_to_add) = best_item {\n                is_selected[idx_to_add] = true;\n                current_weight += weights[idx_to_add];\n                current_value += marginal_gains[idx_to_add]; // Update value incrementally\n\n                // Update marginal gains for ALL items (O(N) step). \n                for i in 0..num_items {\n                    marginal_gains[i] += interactions[idx_to_add][i] as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    // Finalize solution indices from the best solution found\n    let selected: Vec<usize> = (0..num_items).filter(|&i| best_solution[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}", "language": "rust", "parent_id": "24582be5-1809-4562-a6db-06172bea875e", "generation": 3, "timestamp": 1766145801.3409886, "iteration_found": 51, "metrics": {"avg_btb": 0.0007374600000000001, "combined_score": 0.4263667125966661, "eval_time": 0.978198338, "memory": 358400.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 196 lines with 298 lines", "parent_metrics": {"avg_btb": 0.00065841, "combined_score": 0.3252870166533226, "eval_time": 0.270581263, "memory": 371200.0}, "island": 0}, "prompts": {"diff_user": {"system": "SETTING:\nYou are an expert Rust programmer specializing in combinatorial optimization algorithms with deep expertise in knapsack problems, resource allocation algorithms, and constraint satisfaction.\nYour mission is to evolve and optimize a quadratic knapsack algorithm that outputs the highest quality possible.\n\n\n=== CRITICAL OUTPUT FORMAT RULES ===\n1. Output ONLY raw Rust source code\n2. Include the complete file from first line to last line\n=== END OUTPUT FORMAT RULES ===\n\nAlgorithm Improvement Instructions:\n\nObjective\nImprove the knapsack algorithm to maximize the total value while respecting the weight constraint.\n\nCRITICAL Constraints\n- You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END\n- Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified\n- You MUST NOT modify the function signature\n- You MUST NOT modify lines before // EVOLVE-BLOCK-START\n- You MUST NOT modify lines after // EVOLVE-BLOCK-END\n- You MUST preserve the exact structure of code outside the evolve block\n\nInput: challenge parameter (type: &Challenge)\n\nThe challenge parameter provides access to the following fields with these EXPLICIT types:\n\n- challenge.seed: [u8; 32] - Fixed-size array of 32 bytes for seeding random number generators\n- challenge.weights: Vec<u32> - Vector of unsigned 32-bit integers representing each item's weight\n- challenge.values: Vec<u32> - Vector of unsigned 32-bit integers representing each item's base value\n- challenge.interaction_values: Vec<Vec<i32>> - 2D matrix (vector of vectors) of SIGNED 32-bit integers\n  - interaction_values[i][j] gives the bonus value when items i and j are BOTH selected\n  - This matrix is symmetric: interaction_values[i][j] == interaction_values[j][i]\n  - Diagonal is zero: interaction_values[i][i] == 0\n- challenge.max_weight: u32 - Unsigned 32-bit integer representing maximum total weight allowed\n  \nImportant notes:\n- All vectors have the same length (number of items)\n- challenge.weights.len() = challenge.values.len() = challenge.interaction_values.len()\n- Item indices are 0 to n-1 where n = challenge.values.len()\n- the structure of the algorithm i.e. the inputs and outputs are fixed, you can only modify the body of the algorithm.\n\nOutput: selected variable (type: Vec<usize>)\n\nYour code must create a variable named selected with the following specification:\n\n- Type: Vec<usize> (vector of unsigned size integers)\n- Content: Indices of items to include in the knapsack solution\n- Valid range: Each element must be in range [0, n-1] where n = challenge.values.len()\n- No duplicates: Each item index can appear at most once\n- Weight constraint: The sum of challenge.weights[i] for all i in selected must be \u2264 challenge.max_weight\n\nThe selected variable is automatically saved after the evolve block ends.\n\nContext:\n- This is a QUADRATIC knapsack problem with interaction values between items\n- Items have: weights, values, and interaction_values (2D matrix)\n- Total value = sum of item values + sum of interaction values for pairs of selected items\n- Constraint: total weight must not exceed max_weight which is half the weight of all items\n- The \"density\" of the knapsack is 25% - meaning interaction values in the symmetric interaction matrix are 0 with probability 0.75; otherwise a random number between 1 and 100.\n\nBENCHMARK:\n- Beat the state-of-the-art result of avg_btb = 0.0015.\n\nHyperparameters (Optional):\nIf your algorithm uses tunable parameters (e.g., iteration counts, thresholds, probabilities),\nyou can define them inside the EVOLVE-BLOCK. Follow these examples exactly.\n\nCRITICAL: The examples below show raw Rust code. Do NOT wrap them in markdown code fences.\n\n\nStep 1 - Define a Hyperparameters struct inside the EVOLVE-BLOCK:\n\n#[derive(Serialize, Deserialize)]\npub struct Hyperparameters {\n    pub max_iterations: usize,\n    pub temperature: f64,\n}\n\nStep 2 - Parse hyperparameters at the start of your code block:\n\nlet hyperparameters = match _hyperparameters {\n    Some(params) => {\n        serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n            .map_err(|e| anyhow!(\"Failed to parse hyperparameters: {}\", e))?\n    }\n    None => Hyperparameters {\n        max_iterations: 100,\n        temperature: 0.95,\n    },\n};\n\nStep 3 - Use the hyperparameter values in your algorithm:\n\nfor _ in 0..hyperparameters.max_iterations {\n    // your algorithm logic here\n}\n\n\nRandom numbers:\nIf you need random numbers, recommend using SmallRng with challenge.seed:\nlet mut rng = SmallRng::from_seed(challenge.seed);\n\nMake sure you use\n- Optimised sorting strategies \n- Efficient data structures for tracking selected items\n\nImportant:\n- Only modify code within the EVOLVE-BLOCK\n- Ensure the algorithm terminates within reasonable time\n- Use the provided Challenge struct fields: values, weights, interaction_values, max_weight\n- The variable selected is automatically saved after the evolve block ends\n\nPERFORMANCE METRICS:\n1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)\n2. **combined_score**: progress toward beating the state-of-the-art benchmark\n3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)\n4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)\n\nTECHNICAL REQUIREMENTS:\n- **Error handling**: Graceful handling of optimization failures or infeasible configurations\n- **Memory efficiency**: Avoid excessive memory allocation for matrix computations\n", "user": "# Current Program Information\n- Fitness: 0.3253\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.3253\n- Consider simplifying - code length exceeds 2000 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 24 lines with 181 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.2465, memory: 371200.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 16 lines with 22 lines\nChange 2: Replace 108 lines with 150 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 11.5252, memory: 380204.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 5 lines with 66 lines\n- Metrics: avg_btb: 0.0007, combined_score: 0.3253, eval_time: 0.3127, memory: 371200.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        // interaction_sums[i] = Sum of interaction values between item i and all currently selected items k.\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            // Iterate over all possible 1-opt swaps (i out, j in) using a best-improvement strategy.\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx]; // Item to remove\n                for item_j in 0..num_items { // Item to add\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    // Efficiently calculate the change in total value for the swap.\n                    // Delta V = (V[j] - V[i]) + (Sum_{k in S, k!=i} I(j, k)) - (Sum_{k in S, k!=i} I(i, k))\n                    // This is equivalent to: V[j] - V[i] + (interaction_sums[j] - I(j,i)) - (interaction_sums[i] - I(i,i))\n                    // Since I(i,i) is 0, it simplifies to the expression below.\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                // Execute the best swap found.\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                // Update interaction_sums efficiently in O(N) instead of recalculating.\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                // No more profitable swaps exist; local optimum reached.\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.3127), Performs well on memory (371200.0000)\n\n### Program 2 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_iterations: usize,\n        pub initial_temperature: f64,\n        pub cooling_rate: f64,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_iterations: 500, // Reduced iterations for safer O(N^2) complexity\n                    initial_temperature: 100.0,\n                    cooling_rate: 0.99,\n                })\n        }\n        None => Hyperparameters {\n            max_iterations: 500,\n            initial_temperature: 100.0,\n            cooling_rate: 0.99,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Simulated Annealing, O(L * N^2)) ---\n    \n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // Calculate initial value V0\n    let mut current_value = {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n    \n    let mut best_solution = is_selected.clone();\n    let mut best_value = current_value;\n\n    #[derive(Debug, Clone, Copy, PartialEq)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n        None,\n    }\n\n    let mut temperature = hyperparameters.initial_temperature;\n    let cooling_rate = hyperparameters.cooling_rate;\n    let max_iterations = hyperparameters.max_iterations;\n\n    for _ in 0..max_iterations {\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: LS_Move = LS_Move::None;\n\n        // O(N^2) Best Improvement search for the current iteration\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = LS_Move::Remove(j);\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = MG[i] - interactions[i][j] - MG[j]\n                            let delta_v_swap = marginal_gains[i] - interactions[i][j] as i64 - marginal_gains[j];\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = LS_Move::Swap(j, i);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = LS_Move::Add(i);\n                    }\n                }\n            }\n        }\n\n        // --- SA Acceptance Criterion ---\n        let accept_move = match best_move {\n            LS_Move::None => false,\n            _ => {\n                if best_delta_v > 0 {\n                    true // Always accept improving moves\n                } else if temperature > 1e-6 {\n                    // Accept non-improving moves probabilistically\n                    let acceptance_prob = (-best_delta_v as f64 / temperature).exp();\n                    rng.gen::<f64>() < acceptance_prob\n                } else {\n                    false\n                }\n            }\n        };\n\n        // --- Execute Accepted Move ---\n        if accept_move {\n            current_value += best_delta_v;\n\n            match best_move {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::None => {}\n            }\n            \n            // Update best solution found so far\n            if current_value > best_value {\n                best_value = current_value;\n                best_solution = is_selected.clone();\n            }\n        }\n\n        // Cooling schedule\n        if temperature > 1e-6 { \n            temperature *= cooling_rate;\n        }\n    }\n    \n    // Use the best solution found during the SA run\n    is_selected = best_solution;\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (11.5252), Performs well on memory (380204.0000)\n\n### Program 3 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 50, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 50,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Best Improvement, O(L * N^2)) ---\n    \n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        // Weight check: current_weight - w_j + w_i <= max_weight\n                        // Since j is selected, current_weight >= w_j.\n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = MG[i] - interactions[i][j] - MG[j]\n                            let delta_v_swap = marginal_gains[i] - interactions[i][j] as i64 - marginal_gains[j];\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Performs well on avg_btb (0.0007), Performs well on combined_score (0.3253), Performs well on eval_time (0.2465), Performs well on memory (371200.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    // Phase 1: Greedy construction using marginal density.\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    let gain = marginal_gains[i];\n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n### Program D2 (Score: 0.3253)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // Phase 1: An O(N^2) greedy algorithm that considers interaction values.\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        // Pre-calculate the sum of interactions for each item with the current solution.\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        #[derive(Debug, Clone, Copy)]\n        enum LS_Move {\n            Add(usize), // item_j\n            Remove(usize, usize), // (item_i, i_vec_idx)\n            Swap(usize, usize, usize), // (item_i, item_j, i_vec_idx)\n        }\n\n        loop {\n            let mut best_delta_v = 0i64;\n            let mut best_move: Option<LS_Move> = None; \n\n            // 1. Check Add moves (j in)\n            for j in 0..num_items {\n                if !is_selected[j] {\n                    let w_j = challenge.weights[j];\n                    if current_weight.checked_add(w_j).map_or(false, |w| w <= challenge.max_weight) {\n                        // Delta V = V[j] + interaction_sums[j]\n                        let delta_v_add = challenge.values[j] as i64 + interaction_sums[j];\n\n                        if delta_v_add > best_delta_v {\n                            best_delta_v = delta_v_add;\n                            best_move = Some(LS_Move::Add(j));\n                        }\n                    }\n                }\n            }\n\n            // 2. Check Remove and Swap moves (i out)\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n\n                // --- Remove Move (i out) ---\n                // Delta V = - (V[i] + interaction_sums[i])\n                let delta_v_remove = -(challenge.values[item_i] as i64 + interaction_sums[item_i]);\n\n                if delta_v_remove > best_delta_v {\n                    best_delta_v = delta_v_remove;\n                    best_move = Some(LS_Move::Remove(item_i, i_vec_idx));\n                }\n\n                // --- Swap Moves (i out, j in) ---\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    // Delta V calculation for swapping i out and j in:\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > best_delta_v {\n                        best_delta_v = delta_value;\n                        best_move = Some(LS_Move::Swap(item_i, item_j, i_vec_idx));\n                    }\n                }\n            }\n\n            if best_delta_v > 0 {\n                // Execute Best Move\n                match best_move.unwrap() {\n                    LS_Move::Add(item_j) => {\n                        is_selected[item_j] = true;\n                        current_weight += challenge.weights[item_j];\n                        selected.push(item_j); \n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] += challenge.interaction_values[k][item_j] as i64;\n                        }\n                    }\n                    LS_Move::Remove(item_i, i_vec_idx) => {\n                        is_selected[item_i] = false;\n                        current_weight -= challenge.weights[item_i];\n                        \n                        // Remove from the selected vector by swapping with the last element\n                        selected.swap_remove(i_vec_idx);\n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] -= challenge.interaction_values[k][item_i] as i64;\n                        }\n                    }\n                    LS_Move::Swap(item_i, item_j, i_vec_idx) => {\n                        let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                        current_weight = (current_weight as i64 + delta_weight) as u32;\n                        \n                        is_selected[item_i] = false;\n                        is_selected[item_j] = true;\n                        selected[i_vec_idx] = item_j; // Replace item_i with item_j in the selected vector\n\n                        // Update interaction_sums efficiently in O(N).\n                        for k in 0..num_items {\n                            interaction_sums[k] += (challenge.interaction_values[k][item_j] - challenge.interaction_values[k][item_i]) as i64;\n                        }\n                    }\n                }\n            } else {\n                // No more improving moves found, local optimum reached.\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nKey features: Alternative approach to avg_btb, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 50, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 50,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (Best Improvement, O(L * N^2)) ---\n    \n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        // Weight check: current_weight - w_j + w_i <= max_weight\n                        // Since j is selected, current_weight >= w_j.\n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = MG[i] - interactions[i][j] - MG[j]\n                            let delta_v_swap = marginal_gains[i] - interactions[i][j] as i64 - marginal_gains[j];\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 24 lines with 181 lines, Alternative avg_btb approach, Alternative eval_time approach\n\n### Inspiration 2 (Score: 0.3253, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    // Phase 1: Greedy construction using marginal density.\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    let gain = marginal_gains[i];\n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n\n    // Phase 2: Local search (1-opt swap) to improve the greedy solution.\n    if !selected.is_empty() {\n        let mut interaction_sums = vec![0i64; num_items];\n        for i in 0..num_items {\n            for &k in &selected {\n                interaction_sums[i] += challenge.interaction_values[i][k] as i64;\n            }\n        }\n\n        loop {\n            let mut best_swap: Option<(usize, usize, i64)> = None; // (index_in_selected_vec, item_to_add_idx, delta_value)\n\n            for i_vec_idx in 0..selected.len() {\n                let item_i = selected[i_vec_idx];\n                for item_j in 0..num_items {\n                    if is_selected[item_j] { continue; }\n\n                    let delta_weight = challenge.weights[item_j] as i64 - challenge.weights[item_i] as i64;\n                    if (current_weight as i64 + delta_weight) > challenge.max_weight as i64 {\n                        continue;\n                    }\n\n                    let delta_value = (challenge.values[item_j] as i64 - challenge.values[item_i] as i64)\n                                    + (interaction_sums[item_j] - challenge.interaction_values[item_j][item_i] as i64)\n                                    - interaction_sums[item_i];\n\n                    if delta_value > 0 {\n                        if best_swap.is_none() || delta_value > best_swap.unwrap().2 {\n                            best_swap = Some((i_vec_idx, item_j, delta_value));\n                        }\n                    }\n                }\n            }\n\n            if let Some((i_vec_idx_to_swap, item_j_to_swap, _)) = best_swap {\n                let item_i_to_swap = selected[i_vec_idx_to_swap];\n\n                let delta_weight = challenge.weights[item_j_to_swap] as i64 - challenge.weights[item_i_to_swap] as i64;\n                current_weight = (current_weight as i64 + delta_weight) as u32;\n                is_selected[item_i_to_swap] = false;\n                is_selected[item_j_to_swap] = true;\n                selected[i_vec_idx_to_swap] = item_j_to_swap;\n\n                for k in 0..num_items {\n                    interaction_sums[k] += (challenge.interaction_values[k][item_j_to_swap] - challenge.interaction_values[k][item_i_to_swap]) as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 45 lines with 90 lines, Alternative avg_btb approach, Alternative eval_time approach\n\n### Inspiration 3 (Score: 0.0499, Type: Exploratory)\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        // Optionally define hyperparameters here\n    }\n\n    // An O(N^2) greedy algorithm that considers interaction values (QKP specific).\n    // At each step, it adds the item with the highest \"marginal density\".\n    // Marginal density = (item's base value + sum of interactions with already selected items) / item's weight.\n    let num_items = challenge.values.len();\n    \n    let mut selected = Vec::new();\n    let mut current_weight: u32 = 0;\n    let mut is_selected = vec![false; num_items];\n    // Use i64 for marginal gains to handle negative interactions and sums\n    let mut marginal_gains: Vec<i64> = challenge.values.iter().map(|&v| v as i64).collect();\n\n    loop {\n        let mut best_item_idx: Option<usize> = None;\n        let mut max_density = f64::NEG_INFINITY;\n\n        // Find the best item to add from the unselected items\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = challenge.weights[i];\n                if current_weight + item_weight <= challenge.max_weight {\n                    \n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        // Handle zero-weight items: prioritize positive gain infinitely\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > max_density {\n                        max_density = density;\n                        best_item_idx = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item_idx {\n            selected.push(idx_to_add);\n            current_weight += challenge.weights[idx_to_add];\n            is_selected[idx_to_add] = true;\n\n            // Update marginal gains of remaining items based on the new item\n            // This is the core quadratic complexity step.\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    // interaction_values[idx_to_add][i] is the bonus gained if i is selected alongside idx_to_add\n                    marginal_gains[i] += challenge.interaction_values[idx_to_add][i] as i64;\n                }\n            }\n        } else {\n            // No more items can be added\n            break;\n        }\n    }\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\nUnique approach: Modification: Change 1: Replace 24 lines with 61 lines, Alternative avg_btb approach, Alternative combined_score approach\n\n# Current Program\n```rust\n// DO NOT CHANGE THESE IMPORTS\nuse crate::challenge::{Challenge, Solution};\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::{Map, Value};\nuse rand::{rngs::SmallRng, Rng, SeedableRng};\n\npub fn solve_challenge(\n    challenge: &Challenge,\n    save_solution: &dyn Fn(&Solution) -> Result<()>,\n    _hyperparameters: &Option<Map<String, Value>>,\n) -> Result<()> {\n    // EVOLVE-BLOCK-START    \n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 50, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 50,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (First Improvement, O(L * N^2)) ---\n    \n    // Calculate initial value V0 (used for tracking improvement)\n    let mut current_value = {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n\n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = -MG[j] + (MG[i] - interactions[i][j])\n                            let delta_v_swap = delta_v_remove_j + marginal_gains[i] - interactions[i][j] as i64;\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n            current_value += best_delta_v;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n    // EVOLVE-BLOCK-END\n    \n    save_solution(&Solution { items: selected })?;\n    Ok(())\n}\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["This evolution introduces an Iterated Local Search (ILS) metaheuristic. Instead of relying on a single run of Best Improvement Local Search (BILS) which often gets stuck in shallow local optima, ILS repeatedly perturbs the current local optimum and applies BILS again. This significantly enhances the exploration capability, aiming for a higher quality solution (better `avg_btb`).\n\nThe core changes involve:\n1. Defining new hyperparameters (`max_restarts`, `perturbation_size`).\n2. Encapsulating the BILS logic into a reusable closure (`run_bils`).\n3. Implementing helper functions to calculate value and marginal gains from scratch for state restoration/verification.\n4. Wrapping the optimization process in an ILS loop that performs BILS, updates the global best solution, perturbs the solution (random removal followed by greedy repair), and repeats.\n\n<<<<<<< SEARCH\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_ls_iterations: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_ls_iterations: 50, // Default reasonable limit\n                })\n        }\n        None => Hyperparameters {\n            max_ls_iterations: 50,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    // --- State Variables ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    \n    // marginal_gains[i] = values[i] + sum(interactions[i][j]) for all j currently selected.\n    // This allows O(1) calculation of Add/Remove/Swap delta values in LS.\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n\n    // --- 1. Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            // This prepares the MG array for the local search phase.\n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // --- 2. Local Search Phase (First Improvement, O(L * N^2)) ---\n    \n    // Calculate initial value V0 (used for tracking improvement)\n    let mut current_value = {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n\n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    let mut improved = true;\n    let mut iteration_count = 0;\n\n    while improved && iteration_count < hyperparameters.max_ls_iterations {\n        improved = false;\n        iteration_count += 1;\n        \n        let mut best_delta_v = 0i64;\n        let mut best_move: Option<LS_Move> = None;\n\n        // Iterate over all possible moves (O(N^2) neighborhood search)\n        for j in 0..num_items {\n            if is_selected[j] {\n                // Item j is selected: Check Remove and Swap moves involving j\n\n                // --- Remove Move (j out) ---\n                // Delta V = -MG[j]\n                let delta_v_remove_j = -marginal_gains[j];\n                if delta_v_remove_j > best_delta_v {\n                    best_delta_v = delta_v_remove_j;\n                    best_move = Some(LS_Move::Remove(j));\n                }\n\n                // --- Swap Moves (j out, i in) ---\n                let w_j = weights[j];\n                \n                for i in 0..num_items {\n                    if !is_selected[i] {\n                        let w_i = weights[i];\n                        \n                        let new_weight = current_weight - w_j + w_i;\n                        \n                        if new_weight <= max_weight {\n                            // Delta V(j out, i in) = -MG[j] + (MG[i] - interactions[i][j])\n                            let delta_v_swap = delta_v_remove_j + marginal_gains[i] - interactions[i][j] as i64;\n\n                            if delta_v_swap > best_delta_v {\n                                best_delta_v = delta_v_swap;\n                                best_move = Some(LS_Move::Swap(j, i));\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Item i is unselected: Check Add moves\n                let i = j;\n                let w_i = weights[i];\n\n                // --- Add Move (i in) ---\n                if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                    // Delta V = MG[i]\n                    let delta_v_add_i = marginal_gains[i];\n\n                    if delta_v_add_i > best_delta_v {\n                        best_delta_v = delta_v_add_i;\n                        best_move = Some(LS_Move::Add(i));\n                    }\n                }\n            }\n        }\n\n        // --- Execute Best Move ---\n        if best_delta_v > 0 {\n            improved = true;\n            current_value += best_delta_v;\n\n            match best_move.unwrap() {\n                LS_Move::Add(i) => {\n                    is_selected[i] = true;\n                    current_weight += weights[i];\n                    \n                    // Update MG for all items based on adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] += interactions[i][k] as i64;\n                    }\n                }\n                LS_Move::Remove(j) => {\n                    is_selected[j] = false;\n                    current_weight -= weights[j];\n                    \n                    // Update MG for all items based on removing j (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] -= interactions[j][k] as i64;\n                    }\n                }\n                LS_Move::Swap(j, i) => {\n                    is_selected[j] = false;\n                    is_selected[i] = true;\n                    current_weight = current_weight - weights[j] + weights[i];\n                    \n                    // Update MG for all items based on removing j AND adding i (O(N))\n                    for k in 0..num_items {\n                        marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                    }\n                }\n            }\n        }\n    }\n\n    // Finalize solution indices\n    let selected: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n=======\n    #[derive(Serialize, Deserialize)]\n    pub struct Hyperparameters {\n        pub max_restarts: usize,\n        pub perturbation_size: usize,\n    }\n\n    let hyperparameters = match _hyperparameters {\n        Some(params) => {\n            serde_json::from_value::<Hyperparameters>(Value::Object(params.clone()))\n                .unwrap_or(Hyperparameters {\n                    max_restarts: 10, // Increased restarts for better exploration\n                    perturbation_size: 5, \n                })\n        }\n        None => Hyperparameters {\n            max_restarts: 10,\n            perturbation_size: 5,\n        },\n    };\n\n    let num_items = challenge.values.len();\n    let weights = &challenge.weights;\n    let values = &challenge.values;\n    let interactions = &challenge.interaction_values;\n    let max_weight = challenge.max_weight;\n\n    let mut rng = SmallRng::from_seed(challenge.seed);\n\n    // --- State Variables (Current Solution) ---\n    let mut is_selected = vec![false; num_items];\n    let mut current_weight: u32 = 0;\n    let mut marginal_gains: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n    let mut current_value: i64 = 0;\n\n    // --- Best Solution Tracking ---\n    let mut best_solution = vec![false; num_items];\n    let mut best_value = i64::MIN;\n\n    #[derive(Debug, Clone, Copy)]\n    enum LS_Move {\n        Add(usize),\n        Remove(usize),\n        Swap(usize, usize), // (item_to_remove, item_to_add)\n    }\n\n    // Helper function to run Best Improvement Local Search (BILS) until convergence\n    // Modifies state variables in place.\n    let mut run_bils = |\n        is_selected: &mut Vec<bool>,\n        current_weight: &mut u32,\n        marginal_gains: &mut Vec<i64>,\n        current_value: &mut i64\n    | {\n        loop {\n            let mut best_delta_v = 0i64;\n            let mut best_move: Option<LS_Move> = None;\n\n            // O(N^2) neighborhood search\n            for j in 0..num_items {\n                if is_selected[j] {\n                    // Item j is selected: Check Remove and Swap moves involving j\n\n                    // --- Remove Move (j out) ---\n                    let delta_v_remove_j = -marginal_gains[j];\n                    if delta_v_remove_j > best_delta_v {\n                        best_delta_v = delta_v_remove_j;\n                        best_move = Some(LS_Move::Remove(j));\n                    }\n\n                    // --- Swap Moves (j out, i in) ---\n                    let w_j = weights[j];\n                    \n                    for i in 0..num_items {\n                        if !is_selected[i] {\n                            let w_i = weights[i];\n                            \n                            // Check weight constraint for swap\n                            let delta_w = w_i as i64 - w_j as i64;\n                            if (*current_weight as i64 + delta_w) <= max_weight as i64 {\n                                \n                                // Delta V(j out, i in) = -MG[j] + (MG[i] - interactions[i][j])\n                                let delta_v_swap = delta_v_remove_j + marginal_gains[i] - interactions[i][j] as i64;\n\n                                if delta_v_swap > best_delta_v {\n                                    best_delta_v = delta_v_swap;\n                                    best_move = Some(LS_Move::Swap(j, i));\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    // Item i is unselected: Check Add moves\n                    let i = j;\n                    let w_i = weights[i];\n\n                    // --- Add Move (i in) ---\n                    if current_weight.checked_add(w_i).map_or(false, |w| w <= max_weight) {\n                        let delta_v_add_i = marginal_gains[i];\n\n                        if delta_v_add_i > best_delta_v {\n                            best_delta_v = delta_v_add_i;\n                            best_move = Some(LS_Move::Add(i));\n                        }\n                    }\n                }\n            }\n\n            if best_delta_v > 0 {\n                *current_value += best_delta_v;\n\n                match best_move.unwrap() {\n                    LS_Move::Add(i) => {\n                        is_selected[i] = true;\n                        *current_weight += weights[i];\n                        for k in 0..num_items {\n                            marginal_gains[k] += interactions[i][k] as i64;\n                        }\n                    }\n                    LS_Move::Remove(j) => {\n                        is_selected[j] = false;\n                        *current_weight -= weights[j];\n                        for k in 0..num_items {\n                            marginal_gains[k] -= interactions[j][k] as i64;\n                        }\n                    }\n                    LS_Move::Swap(j, i) => {\n                        is_selected[j] = false;\n                        is_selected[i] = true;\n                        *current_weight = *current_weight - weights[j] + weights[i];\n                        for k in 0..num_items {\n                            marginal_gains[k] = marginal_gains[k] - interactions[j][k] as i64 + interactions[i][k] as i64;\n                        }\n                    }\n                }\n            } else {\n                break; // Local optimum reached\n            }\n        }\n    };\n\n    // Helper function to calculate current value from scratch\n    let calculate_current_value = |is_selected: &[bool]| -> i64 {\n        let mut v = 0i64;\n        for i in 0..num_items {\n            if is_selected[i] {\n                v += values[i] as i64;\n                for j in (i + 1)..num_items {\n                    if is_selected[j] {\n                        v += interactions[i][j] as i64;\n                    }\n                }\n            }\n        }\n        v\n    };\n    \n    // Helper function to calculate marginal gains from scratch\n    let calculate_marginal_gains = |is_selected: &[bool]| -> Vec<i64> {\n        let mut mg: Vec<i64> = values.iter().map(|&v| v as i64).collect();\n        for i in 0..num_items {\n            if is_selected[i] {\n                for k in 0..num_items {\n                    mg[k] += interactions[i][k] as i64;\n                }\n            }\n        }\n        mg\n    };\n\n    // --- 1. Initial Greedy Construction Phase (O(N^2)) ---\n    loop {\n        let mut best_item: Option<usize> = None;\n        let mut best_density: f64 = f64::NEG_INFINITY;\n\n        for i in 0..num_items {\n            if !is_selected[i] {\n                let item_weight = weights[i];\n                if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                    let gain = marginal_gains[i];\n                    \n                    let density = if item_weight == 0 {\n                        if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                    } else {\n                        gain as f64 / item_weight as f64\n                    };\n\n                    if density > best_density {\n                        best_density = density;\n                        best_item = Some(i);\n                    }\n                }\n            }\n        }\n\n        if let Some(idx_to_add) = best_item {\n            is_selected[idx_to_add] = true;\n            current_weight += weights[idx_to_add];\n\n            // Update marginal gains for ALL items (O(N) step). \n            for i in 0..num_items {\n                marginal_gains[i] += interactions[idx_to_add][i] as i64;\n            }\n        } else {\n            break;\n        }\n    }\n    \n    // Initialize current_value after greedy phase\n    current_value = calculate_current_value(&is_selected);\n    best_value = current_value;\n    best_solution = is_selected.clone();\n\n    // --- 2. Iterated Local Search (ILS) ---\n    for restart in 0..hyperparameters.max_restarts {\n        \n        // A. Run BILS on the current state until local optimum is reached\n        run_bils(&mut is_selected, &mut current_weight, &mut marginal_gains, &mut current_value);\n\n        // B. Update Best Solution\n        if current_value > best_value {\n            best_value = current_value;\n            best_solution = is_selected.clone();\n        }\n\n        if restart == hyperparameters.max_restarts - 1 {\n            break; // No need to perturb after the last optimization run\n        }\n\n        // C. Perturbation Phase (Randomly remove items + Greedy Repair)\n        let selected_indices: Vec<usize> = (0..num_items).filter(|&i| is_selected[i]).collect();\n        let num_selected = selected_indices.len();\n        \n        let p_size = hyperparameters.perturbation_size.min(num_selected);\n        \n        // 1. Randomly remove P_size items\n        let mut items_to_remove = Vec::with_capacity(p_size);\n        let mut temp_selected = selected_indices.clone();\n        \n        for _ in 0..p_size {\n            if temp_selected.is_empty() { break; }\n            let idx_in_temp = rng.gen_range(0..temp_selected.len());\n            let item_j = temp_selected.swap_remove(idx_in_temp);\n            items_to_remove.push(item_j);\n        }\n\n        for j in items_to_remove {\n            if is_selected[j] {\n                is_selected[j] = false;\n                current_weight -= weights[j];\n            }\n        }\n\n        // 2. Recalculate state variables (MG and Value) based on the perturbed solution\n        current_value = calculate_current_value(&is_selected);\n        marginal_gains = calculate_marginal_gains(&is_selected);\n\n        // 3. Greedy Repair (Add items back based on marginal density)\n        loop {\n            let mut best_item: Option<usize> = None;\n            let mut best_density: f64 = f64::NEG_INFINITY;\n\n            for i in 0..num_items {\n                if !is_selected[i] {\n                    let item_weight = weights[i];\n                    if current_weight.checked_add(item_weight).map_or(false, |w| w <= max_weight) {\n                        let gain = marginal_gains[i];\n                        \n                        let density = if item_weight == 0 {\n                            if gain > 0 { f64::INFINITY } else { f64::NEG_INFINITY }\n                        } else {\n                            gain as f64 / item_weight as f64\n                        };\n\n                        if density > best_density {\n                            best_density = density;\n                            best_item = Some(i);\n                        }\n                    }\n                }\n            }\n\n            if let Some(idx_to_add) = best_item {\n                is_selected[idx_to_add] = true;\n                current_weight += weights[idx_to_add];\n                current_value += marginal_gains[idx_to_add]; // Update value incrementally\n\n                // Update marginal gains for ALL items (O(N) step). \n                for i in 0..num_items {\n                    marginal_gains[i] += interactions[idx_to_add][i] as i64;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    // Finalize solution indices from the best solution found\n    let selected: Vec<usize> = (0..num_items).filter(|&i| best_solution[i]).collect();\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}