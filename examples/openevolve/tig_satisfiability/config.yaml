# OpenEvolve Configuration for TIG Knapsack Algorithm Evolution
# This configuration evolves Rust algorithms for the quadratic knapsack problem

# Evolution settings

max_iterations: 200
checkpoint_interval: 10 #2
random_seed: 42
diff_based_evolution: True
max_code_length: 40000  # Increased from 10000 for deeper exploration
file_suffix: ".rs"
language: rust  # <-- Add this line


# LLM configuration

llm:
  # primary_model: "gemini-2.5-pro"
  # primary_model: "gpt-5-mini"
  # primary_model: "llama3.1-8b"
  # primary_model: "anthropic/claude-3.7-sonnet"
  primary_model: "gemini-flash-latest"
  # primary_model: "gemma-3-27b-it"

  primary_model_weight: 0.8
  secondary_model: "gemini-pro-latest"
  # secondary_model: "gemma-3-27b-it"
  # secondary_model: "llama-4-scout-17b-16e-instruct"
  # secondary_model: "gpt-5-nano"
  # secondary_model: "anthropic/claude-sonnet-4-5"
  secondary_model_weight: 0.2
  api_base: "https://generativelanguage.googleapis.com/v1beta/openai/"
  # api_base: "https://openrouter.ai/api/v1"
  # api_base: "https://api.openai.com/v1"
  temperature: 0.4 # Optimal (better than 0.2, 0.6, 0.8) for lu factorization, maybe need to tune for knapsack
  max_tokens: 16000 #128000
  timeout: 120 #150
  retries: 2 #3
  retry_delay: 5      # Seconds between retries


# Database configuration
database:
  population_size: 40
  num_islands: 5

  migration_interval: 40   # Migrate every N iterations (default 50 is high for 20 iterations)
  migration_rate: 0.1  
  
  # Feature dimensions for sorting algorithms
  feature_dimensions:
    - "score"            # Overall performance score
    - "complexity" # Length of the algorithm
  feature_bins: 8

# Evaluator configuration
evaluator:
  timeout: 60  # Allow enough time for compilation + 1000 seeds evaluation
  parallel_evaluations: 1
  
  # Direct evaluation - evaluator doesn't implement cascade functions
  cascade_evaluation: false

# Prompt configuration
prompt:
  system_message: |
    SETTING:
    You are an expert boolean satisfiability specialist specializing in 3-SAT problems.
    Your objective is to design and improve an algorithm for solving the 3-SAT problems.
   
    PROBLEM CONTEXT:
    The Boolean Satisfiability (SAT) challenge: given a Boolean formula, find an assignment of truth values to the variables that makes the formula true. This is a decision problem where the goal is to find any satisfying assignment.

    INPUT FORMAT:
    Your algorithm receives a `Challenge` struct with:
    - `seed: [u8; 32]` - Random seed for reproducible instance generation
    - `num_variables: usize` - Number of Boolean variables (n)
    - `clauses: Vec<Vec<i32>>` - List of clauses, each a vector of three integers representing literals

    Each literal is an integer:
    - Positive `k` = variable `k` (true)
    - Negative `-k` = negation of variable `k` (false)
    - Variables are 1-indexed in clauses

    OUTPUT FORMAT:
    Return a `Solution` struct containing:
    - `variables: Vec<bool>` - Truth assignment for each variable (0-indexed, `variables[0]` = variable 1)

    CONSTRAINTS:
    - All clauses must be satisfied (each must have at least one true literal)
    - Solution must assign a truth value to every variable
    - Variable indices in clauses are 1-based and valid (1 to num_variables)

    SCORING METRIC:
    Binary scoring:
    1. All clauses satisfied: score = 1,000,000
    2. Any clause violated: score = 0
    3. Higher is better. No partial credit.

    ALGORITHM IMPLEMENTATION:
    1. Use the provided `solve_challenge` function signature
    2. Periodically save intermediate solutions using `save_solution(&Solution)`
    3. Return `Ok(())` on success or `Err(anyhow!("error message"))` on failure

    TIPS:
    1. **Deterministic Behavior**: Use the challenge seed for any random number generation
    2. **Incremental Saves**: Save intermediate solutions during long searches
    3. **Data Structures**: Use efficient data structures
    4. **Imports**: New imports must be from std library only
    5. **Hyperparameters**:
      i) Define struct
        ```rust
        {hashtag}[derive(Serialize, Deserialize)]
        pub struct Hyperparameters {
            pub param1: usize,
            pub param2: f64,
        }
        ```
      ii) Parse in solve_challenge:
      ```rust
      let hyperparameters = match hyperparameters {
          Some(hyperparameters) => {
              serde_json::from_value::<Hyperparameters>(Value::Object(hyperparameters.clone()))
                  .map_err(|e| anyhow!("Failed to parse hyperparameters: {}", e))?
          }
          None => Hyperparameters { param1: default_value, param2: default_value },
      };
      ```
      iii) Access via `hyperparameters.param1` in algorithm logic.    

    CRITICAL Constraints
    - You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END
    - Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified
    - You MUST NOT modify the function signature
    - You MUST NOT modify lines before // EVOLVE-BLOCK-START
    - You MUST NOT modify lines after // EVOLVE-BLOCK-END
    - You MUST preserve the exact structure of code outside the evolve block
    - You MUST NOT add new imports or external dependencies
    - You MUST NOT use any external libraries or APIs

    Random numbers:
    If you need random numbers, recommend using SmallRng with challenge.seed:
    let mut rng = SmallRng::from_seed(challenge.seed);

    Make sure you use
    - Optimised sorting strategies 
    - Efficient data structures for tracking selected items

    Important:
    - Only modify code within the EVOLVE-BLOCK
    - Ensure the algorithm terminates within reasonable time
    - Use the provided Challenge struct fields: values, weights, interaction_values, max_weight
    - The variable selected is automatically saved after the evolve block ends
    
    PERFORMANCE METRICS:
    1. **avg_btb**: Average better than baseline; average percentage that the total value of the knapsack solution is better than a baseline value (PRIMARY OBJECTIVE - maximize)
    2. **combined_score**: progress toward beating the state-of-the-art benchmark
    3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)
    4. **memory**: Memory usage in kilobytes (keep reasonable, prefer accuracy over speed)

    TECHNICAL REQUIREMENTS:
    - **Error handling**: Graceful handling of optimization failures or infeasible configurations
    - **Memory efficiency**: Avoid excessive memory allocation for matrix computations
   
  num_top_programs: 3     # Increased from 3-5 for richer learning context
  num_diverse_programs: 2  # Increased from 2 for more diverse exploration
  include_artifacts: true  # +20.7% improvement

  max_artifact_bytes: 20480       # 20KB default - increase if your outputs are large
  suggest_simplification_after_chars: 2000  # Default 500 is low for Rust; your code is longer


# Logging
log_level: "INFO"

early_stopping_patience: 50       # Stop after 50 iterations with no improvement
convergence_threshold: 0.0001    # What counts as "no improvement"
early_stopping_metric: "combined_score" 


evolution_trace:
  enabled: true
  format: "jsonl"  # or "json" for single file
  include_code: true  # IMPORTANT: This saves the actual code
  include_prompts: true  # Saves what the LLM was prompted with
  buffer_size: 10
  compress: false  # Set true to save space with .gz compression