# OpenEvolve Default Configuration
# This file contains all available configuration options with sensible defaults
# You can use this as a template for your own configuration

# General settings
max_iterations: 100                  # Maximum number of evolution iterations
checkpoint_interval: 10               # Save checkpoints every N iterations
log_level: "INFO"                     # Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
log_dir: null                         # Custom directory for logs (default: output_dir/logs)
random_seed: 42                       # Random seed for reproducibility (null = random, 42 = default)

# Evolution settings
diff_based_evolution: true            # Use diff-based evolution (true) or full rewrites (false)
max_code_length: 10000                # Maximum allowed code length in characters

# Early stopping settings
early_stopping_patience: null         # Stop after N iterations without improvement (null = disabled)
convergence_threshold: 0.001          # Minimum improvement required to reset patience counter
early_stopping_metric: "combined_score"  # Metric to track for early stopping

# LLM configuration
llm:
  # Models for evolution
  models:
    # List of available models with their weights
    - name: "gemini-2.0-flash-lite"
      weight: 0.8
    - name: "gemini-2.0-flash"
      weight: 0.2

  # Models for LLM feedback
  evaluator_models:
    # List of available models with their weights
    - name: "gemini-2.0-flash-lite"
      weight: 0.8
    - name: "gemini-2.0-flash"
      weight: 0.2

  # API configuration
  api_base: "https://generativelanguage.googleapis.com/v1beta/openai/"  # Base URL for API (change for non-OpenAI models)
  api_key: null                       # API key (defaults to OPENAI_API_KEY env variable)

  # Generation parameters
  temperature: 0.7                    # Temperature for generation (higher = more creative)
  top_p: 0.95                         # Top-p sampling parameter
  max_tokens: 4096                    # Maximum tokens to generate

  # Request parameters
  timeout: 60                         # Timeout for API requests in seconds
  retries: 3                          # Number of retries for failed requests
  retry_delay: 5                      # Delay between retries in seconds

# Prompt configuration
prompt:
  template_dir: null                  # Custom directory for prompt templates
  system_message: |
    SETTING:
    You are an expert combinatorial optimization specialist specializing in vehicle routing problems.
    Your objective is to design and improve an algorithm for solving the vehicle routing with time windows problem.
   
    PROBLEM CONTEXT:
    The Vehicle Routing Problem with Time Windows (VRPTW) challenge: given a logistics instance consisting of a depot, a fleet of vehicles, and a set of customers with demands and time windows, find a set of vehicle routes that services all customers while respecting capacity and time constraints and minimizing total travel distance.

    This is an optimization problem where the goal is to find a feasible routing solution that outperforms a given baseline.

    INPUT FORMAT:
    Your algorithm receives a `Challenge` struct with the following fields:
    - `seed: [u8; 32]`: Random seed for reproducible instance generation
    - `num_nodes: usize`: Number of nodes in the instance (customers + 1 depot)
    - `customers: Vec<Customer>`: List of customer records, including the depot
    Each `Customer` contains:
    - `x: i32` – X-coordinate
    - `y: i32` – Y-coordinate
    - `demand: i32` – Demand to be serviced
    - `ready_time: i32` – Earliest allowable service start time
    - `due_time: i32` – Latest allowable service start time
    - `service_time: i32` – Duration of service

    Additional instance parameters:
    - `vehicle_capacity: i32` – Maximum demand a single vehicle can carry
    - `fleet_size: usize` – Maximum number of vehicles available
    - `baseline_total_distance: i32` – Distance of the baseline solution used for scoring

    **Notes:**
    - Node `0` is always the depot.
    - Travel time is equal to Euclidean distance between nodes.

    OUTPUT FORMAT:
    Your algorithm must return a `Solution` struct containing:
    - `routes: Vec<Vec<usize>>`: A list of vehicle routes, where each route is an ordered list of node indices starting and ending at the depot (`0`).

    CONSTRAINTS:
    All of the following constraints must be satisfied for a solution to be considered valid:
    1. Every customer (nodes `1..num_nodes-1`) is visited exactly once
    2. Each route starts and ends at the depot
    3. The total demand on each route does not exceed `vehicle_capacity`
    4. The number of routes does not exceed `fleet_size`
    5. Vehicles must arrive at each customer no later than their `due_time`
    6. If a vehicle arrives before `ready_time`, it must wait
    7. Service at each customer lasts exactly `service_time`
    8. Each vehicle must return to the depot before the depot’s `due_time`

    If any constraint is violated, the solution is infeasible.

    SCORING METRIC:
    Solutions are scored using a continuous metric based on improvement over a baseline:
    1. If the solution is infeasible: score = 0
    2. If the solution is feasible:
    ```
    better_than_baseline = 1 - (solution_total_distance / baseline_total_distance)
    ```
    3. Higher scores are better

    ALGORITHM IMPLEMENTATION:
    To implement a solution:
    1. Use the provided `solve_challenge` function signature
    2. Generate routes that cover all customers
    3. Validate feasibility against capacity and time window constraints
    4. Minimize total distance traveled
    5. Periodically save intermediate solutions using:
    ```rust
    save_solution(&Solution { routes })
    ```
    6. Return Ok(()) on success or Err(anyhow!("error message")) on failure    

    CRITICAL Constraints
    - You may ONLY modify code between // EVOLVE-BLOCK-START and // EVOLVE-BLOCK-END
    - Code outside these markers (imports, function wrapper, save_solution call) must NEVER be modified
    - You MUST NOT modify the function signature
    - You MUST NOT modify lines before // EVOLVE-BLOCK-START
    - You MUST NOT modify lines after // EVOLVE-BLOCK-END
    - You MUST preserve the exact structure of code outside the evolve block
    - You MUST NOT add new imports or external dependencies
    - You MUST NOT use any external libraries or APIs

  evaluator_system_message: "You are an expert code reviewer."

  # Number of examples to include in the prompt
  num_top_programs: 3                 # Number of top-performing programs to include
  num_diverse_programs: 2             # Number of diverse programs to include

  # Template stochasticity
  use_template_stochasticity: true    # Use random variations in templates for diversity
  template_variations:                # Different phrasings for parts of the template
    improvement_suggestion:
      - "Here's how we could improve this code:"
      - "I suggest the following improvements:"
      - "We can enhance this code by:"

  # Artifact rendering
  include_artifacts: true             # Include execution outputs/errors in prompt
  max_artifact_bytes: 20480           # Maximum artifact size in bytes (20KB default)
  artifact_security_filter: true      # Apply security filtering to artifacts

  # Feature extraction and program labeling thresholds
  # These control how the LLM perceives and categorizes programs
  suggest_simplification_after_chars: 500     # Suggest simplifying if program exceeds this many characters
  include_changes_under_chars: 100           # Include change descriptions in features if under this length  
  concise_implementation_max_lines: 10        # Label as "concise" if program has this many lines or fewer
  comprehensive_implementation_min_lines: 50  # Label as "comprehensive" if program has this many lines or more

  # Note: meta-prompting features are not yet implemented

# Database configuration
database:
  # General settings
  db_path: null                       # Path to persist database (null = in-memory only)
  in_memory: true                     # Keep database in memory for faster access
  log_prompts: true                  # If true, log all prompts and responses into the database

  # Evolutionary parameters
  population_size: 1000               # Maximum number of programs to keep in memory
  archive_size: 100                   # Size of elite archive
  num_islands: 5                      # Number of islands for island model (separate populations)

  # Island-based evolution parameters
  # Islands provide diversity by maintaining separate populations that evolve independently.
  # Migration periodically shares the best solutions between adjacent islands.
  migration_interval: 50              # Migrate between islands every N generations
  migration_rate: 0.1                 # Fraction of top programs to migrate (0.1 = 10%)

  # Selection parameters
  elite_selection_ratio: 0.1          # Ratio of elite programs to select
  exploration_ratio: 0.2              # Ratio of exploration vs exploitation
  exploitation_ratio: 0.7             # Ratio of exploitation vs random selection
  # Note: diversity_metric is fixed to "edit_distance" (feature_based not implemented)

  # Feature map dimensions for MAP-Elites
  # Default if not specified: ["complexity", "diversity"]
  # 
  # Built-in features (always available, computed by OpenEvolve):
  #   - "complexity": Code length
  #   - "diversity": Code structure diversity
  #
  # You can mix built-in features with custom metrics from your evaluator:
  feature_dimensions:                 # Dimensions for MAP-Elites feature map (for diversity, NOT fitness)
    - "complexity"                    # Code length (built-in)
    - "diversity"                     # Code diversity (built-in)
  # Example with custom features:
  # feature_dimensions:
  #   - "performance"                 # Must be returned by your evaluator
  #   - "correctness"                 # Must be returned by your evaluator
  #   - "memory_efficiency"           # Must be returned by your evaluator
  
  # Number of bins per dimension
  # Can be a single integer (same for all dimensions) or a dict
  feature_bins: 10                    # Number of bins per dimension
  # Example of per-dimension configuration:
  # feature_bins:
  #   complexity: 10                  # 10 bins for complexity
  #   diversity: 15                   # 15 bins for diversity
  #   performance: 20                 # 20 bins for custom metric
  
  diversity_reference_size: 20        # Size of reference set for diversity calculation

# Evaluator configuration
evaluator:
  # Fitness calculation: Uses 'combined_score' if available, otherwise averages
  # all metrics EXCEPT those listed in database.feature_dimensions
  
  # General settings
  timeout: 300                        # Maximum evaluation time in seconds
  max_retries: 3                      # Maximum number of retries for evaluation

  # Note: resource limits (memory_limit_mb, cpu_limit) are not yet implemented

  # Evaluation strategies
  cascade_evaluation: true            # Use cascade evaluation to filter bad solutions early
  cascade_thresholds:                 # Thresholds for advancing to next evaluation stage
    - 0.5                             # First stage threshold
    - 0.75                            # Second stage threshold
    - 0.9                             # Third stage threshold

  # Parallel evaluation
  parallel_evaluations: 4             # Number of parallel evaluations
  # Note: distributed evaluation is not yet implemented

  # LLM-based feedback (experimental)
  use_llm_feedback: false             # Use LLM to evaluate code quality
  llm_feedback_weight: 0.1            # Weight for LLM feedback in final score

# Evolution trace configuration
# Logs detailed traces of program evolution for RL training and analysis
evolution_trace:
  enabled: false                      # Enable evolution trace logging
  format: 'jsonl'                     # Output format: 'jsonl', 'json', or 'hdf5'
  include_code: false                 # Include full program code in traces
  include_prompts: true               # Include prompts and LLM responses
  output_path: null                   # Path for trace output (defaults to output_dir/evolution_trace.{format})
  buffer_size: 10                     # Number of traces to buffer before writing
  compress: false                     # Compress output file (jsonl only)
