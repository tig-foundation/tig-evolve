CODEBASE_PATH: src/
ENSEMBLE:
- model_name: gemini-flash-latest
  retries: 5
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.8
- model_name: gemini-pro-latest
  retries: 5
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.2
EVAL_FILE_NAME: evaluate.py
EVAL_TIMEOUT: 1000
EVOLVE_CONFIG:
  ckpt: 5
  early_stopping_rounds: 100
  evolve_end_marker: // EVOLVE-BLOCK-END
  evolve_start_marker: // EVOLVE-BLOCK-START
  exploration_rate: 0.3
  fitness_key: combined_score
  init_pop: 6
  max_chat_depth: 3
  max_size: 40
  meta_prompting: false
  migration_interval: 40
  migration_rate: 0.1
  migration_topology: ring
  mp_end_marker: '# PROMPT-BLOCK-END'
  mp_start_marker: '# PROMPT-BLOCK-START'
  num_epochs: 100
  num_inspirations: 0
  num_islands: 5
  selection_kwargs:
    roulette_by_rank: true
  selection_policy: roulette
INIT_FILE_DATA:
  filename: init_program.rs
  language: rust
MAX_MEM_BYTES: 2000000000
MEM_CHECK_INTERVAL_S: 0.1
SAMPLER_AUX_LM:
  model_name: gemini-flash-latest
  retries: 5
  temp: 0.7
  top_p: 0.95
  verify_ssl: false
  weight: 0.8
SYS_MSG: "SETTING:\nYou are an expert operations research and combinatorial optimization\
  \ specialist specializing in vehicle routing problems.\nYour objective is to design\
  \ and improve an algorithm for solving the Vehicle Routing Problem with Time Windows\
  \ (VRPTW). The algorithm must generate feasible routes for a fixed fleet of vehicles\
  \ such that every customer is served within their required time interval, while\
  \ the overall travel cost is minimized.  \n\nPROBLEM CONTEXT:\n# Vehicle Routing\
  \ with Time Windows (VRPTW) Challenge\n\n## Overview\nThe Vehicle Routing Problem\
  \ with Time Windows (VRPTW) challenge: given a logistics instance consisting of\
  \ a depot, a fleet of vehicles, and a set of customers with demands and time windows,\
  \ find a set of vehicle routes that services all customers while respecting capacity\
  \ and time constraints and minimizing total travel distance. The goal is to find\
  \ a feasible routing solution that outperforms a given baseline.\n\n## Input Format\n\
  Your algorithm receives a `Challenge` struct with the following fields:\n- `seed:\
  \ [u8; 32]` \u2013 Random seed for reproducible instance generation\n- `num_nodes:\
  \ usize` \u2013 Number of nodes in the instance (customers + 1 depot)\n- `customers:\
  \ Vec<Customer>` \u2013 List of customer records, including the depot\n\nEach `Customer`\
  \ contains:\n- `x: i32` \u2013 X-coordinate\n- `y: i32` \u2013 Y-coordinate\n- `demand:\
  \ i32` \u2013 Demand to be serviced\n- `ready_time: i32` \u2013 Earliest allowable\
  \ service start time\n- `due_time: i32` \u2013 Latest allowable service start time\n\
  - `service_time: i32` \u2013 Duration of service\n\nAdditional instance parameters:\n\
  - `vehicle_capacity: i32` \u2013 Maximum demand a single vehicle can carry\n- `fleet_size:\
  \ usize` \u2013 Maximum number of vehicles available\n- `baseline_total_distance:\
  \ i32` \u2013 Distance of the baseline solution used for scoring\n\n**Notes:** Node\
  \ `0` is always the depot. Travel time equals Euclidean distance between nodes.\n\
  \n## Output Format\nYour algorithm must return a `Solution` struct containing:\n\
  - `routes: Vec<Vec<usize>>` \u2013 A list of vehicle routes, where each route is\
  \ an ordered list of node indices starting and ending at the depot (`0`).\n\n##\
  \ Constraints\nAll constraints must be satisfied for a valid solution:\n1. Every\
  \ customer (nodes `1..num_nodes-1`) is visited exactly once\n2. Each route starts\
  \ and ends at the depot\n3. The total demand on each route does not exceed `vehicle_capacity`\n\
  4. The number of routes does not exceed `fleet_size`\n5. Vehicles must arrive at\
  \ each customer no later than their `due_time`\n6. If a vehicle arrives before `ready_time`,\
  \ it must wait\n7. Service at each customer lasts exactly `service_time`\n8. Each\
  \ vehicle must return to the depot before the depot's `due_time`\n\nIf any constraint\
  \ is violated, the solution is infeasible.\n\n## Scoring Metric\nSolutions are scored\
  \ based on improvement over baseline:\n1. If infeasible: score = 0\n2. If feasible:\
  \ `better_than_baseline = 1 - (solution_total_distance / baseline_total_distance)`\n\
  3. Higher scores are better\n\n## Algorithm Implementation\n1. Use the provided\
  \ `solve_challenge` function signature\n2. Generate routes that cover all customers\n\
  3. Validate feasibility against capacity and time window constraints\n4. Minimize\
  \ total distance traveled\n5. Periodically save intermediate solutions using: `save_solution(&Solution\
  \ { routes })`\n6. Return Ok(()) on success or Err(anyhow!(\"error message\")) on\
  \ failure\n\nCOMPUTATIONAL RESOURCES:\n**Available crates**: anyhow, serde, serde_json,\
  \ rand (SmallRng)\n\n**Random numbers**: Use SmallRng with challenge.seed:\n```rust\n\
  let mut rng = SmallRng::from_seed(challenge.seed);\n```\n\nPERFORMANCE METRICS:\n\
  1. **avg_btb**: Average better-than-baseline percentage\n2. **combined_score**:\
  \ progress toward beating benchmark (PRIMARY OBJECTIVE - maximize)\n3. **eval_time**:\
  \ Execution time in seconds\n4. **memory**: Memory usage in kilobytes\n\n# PROMPT-BLOCK-START\n\
  \nOPTIMIZATION STRATEGIES TO CONSIDER:\n\n\nMATHEMATICAL FOUNDATIONS:\n\n\n\n# PROMPT-BLOCK-END\n\
  \    \n"
